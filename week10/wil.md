# 고급 백엔드 스터디 10주차

## Optimistic Concurrency Control

낙관적 동시성 제어(Optimistic concurrency control)는 트랜잭션 충돌이 드물게 발생한다고 가정하고, 잠금(lock)을 사용하거나 트랜잭션 실행을 차단하는 대신, 커밋 전에 검증(validation)을 통해 동시 실행 중인 트랜잭션 간의 읽기/쓰기 충돌을 방지하고 직렬 가능성을 보장할 수 있다고 봅니다. 일반적으로 트랜잭션 실행은 세 가지 단계로 나뉩니다:

- 낙관적 제어는 '충돌이 거의 없다'는 가정을 전제로 함.
- 이는 비관적 제어와의 가장 큰 차이점 중 하나임.
  - 비관적 제어와 달리 **락을 걸지 않고**, 실행 중인 트랜잭션을 멈추지 않음.
  - 즉, 충돌 예방보다는 사후 검증에 집중함.
- 검증(validation) 단계에서 읽기/쓰기 충돌 여부를 검사함
  - 충돌이 감지되면 트랜잭션을 abort 후 재시도할 수 있음.
  - 이를 통해 직렬 가능성(serializability)을 커밋 전에 보장함

읽기 단계

트랜잭션은 자신의 프라이빗 컨텍스트에서 각 단계를 실행하며, 이 과정에서 다른 트랜잭션에게 변경 사항을 전혀 노출하지 않습니다. 이 단계가 끝나면 모든 트랜잭션 의존성(읽기 집합)과 트랜잭션이 만들어낼 부작용(쓰기 집합)이 알려집니다.

- 트랜잭션 전용 ‘프라이빗 컨텍스트’에서 로직 실행 → 외부에 전혀 노출되지 않음.
- 읽은 레코드 목록 → 읽기 집합(read set) 생성
- 수정 예정 레코드 및 값 → 쓰기 집합(write set) 확정

검증 단계

동시 실행 중인 트랜잭션들의 읽기 집합과 쓰기 집합을 검사하여 직렬 가능성을 위반할 수 있는 잠재적 충돌이 존재하는지 확인합니다. 트랜잭션이 읽던 데이터가 현재 시점에 오래된 값이 되었거나 읽기 단계 동안 커밋된 트랜잭션이 기록한 값을 이 트랜잭션이 덮어쓰게 되는 경우라면, 사적 컨텍스트를 비우고 읽기 단계를 다시 시작합니다. 즉, 검증 단계는 트랜잭션 커밋이 ACID 속성을 보존하는지를 결정합니다.

- 현재 커밋을 시도하는 트랜잭션과 동시에 실행·커밋된 다른 트랜잭션들의 read/write 집합 비교
- 검증 실패 조건 예시
  - 읽기 집합 중 일부 레코드가 검증 시점까지 다른 트랜잭션에 의해 변경됨 → 읽은 데이터가 최신이 아님.
  - 쓰기 집합이 이미 커밋된 다른 트랜잭션의 쓰기 집합과 충돌 → 덮어쓰기 위험 존재
- 실패 시 동작
  - 프라이빗 컨텍스트 초기화 → 읽기 단계부터 재시작
- ACID 중에서 C, I와 관련되어 있음

쓰기 단계

검증 단계에서 충돌이 발견되지 않으면 트랜잭션은 프라이빗 컨텍스트의 쓰기 집합을 데이터베이스 상태에 커밋할 수 있습니다.

→ 그렇구나…

검증은 이미 커밋된 트랜잭션과의 충돌을 확인하는 방식(후향-지향) 또는 현재 검증 단계에 있는 트랜잭션과의 충돌을 확인하는 방식(전향-지향)으로 수행할 수 있습니다. 서로 다른 트랜잭션의 검증 단계와 쓰기 단계는 원자적으로 수행되어야 하며, 어떤 트랜잭션이 검증 중일 때는 다른 트랜잭션이 커밋될 수 없습니다. 검증 단계와 쓰기 단계는 일반적으로 읽기 단계보다 짧으므로 이는 수용 가능한 절충안입니다.

- 검증 방식에는 두 가지가 있다
  - 후향-지향(backward): 이미 **커밋**된 트랜잭션과만 비교 → 과거와 충돌 여부 확인.
  - 전향-지향(forward): 현재 **검증 중**인 트랜잭션끼리도 비교 → 미래 충돌 예방.
- 검증 / 쓰기는 원자적으로 수행된다. 즉 어떤 트랜잭션 검증-쓰기 수행 중에 다른 트랜잭션의 검증-쓰기가 발생할 수 없다.
  - 성능에 문제 없나요? → 검증 및 쓰기는 읽기보다 짧으므로 괜찮음
  - 왜? → 앞 내용 배웠다면 이해할 것. 검증은 메모리 단 연산이므로 비싸지 않고 읽기의 경우 랜덤 읽기이며 쓰기는 순차 쓰기인 경우가 많으므로…

후향-지향 동시성 제어는 트랜잭션 T1과 T2의 임의의 쌍에 대해 다음 성질이 만족되어야 합니다:

T1이 T2의 읽기 단계가 시작되기 전에 커밋되었으면 T2는 커밋될 수 있습니다.

T1이 T2의 쓰기 단계 전에 커밋되었고 T1의 쓰기 집합이 T2의 읽기 집합과 교집합이 없으면, 다시 말해 T1이 T2가 보았어야 할 값을 작성하지 않았다면, 두 트랜잭션은 허용됩니다.

T1의 읽기 단계가 T2의 읽기 단계보다 먼저 완료되었고 T2의 쓰기 집합이 T1의 읽기 집합이나 쓰기 집합과 교집합이 없으면, 즉 두 트랜잭션이 독립적인 데이터 집합에서 작업했다면, 둘 다 커밋될 수 있습니다.

- 후향 지향 동시성 제어
- T1 읽기 → T1 쓰기 → T2 읽기 → T2 쓰기라고 하면 아예 안겹치는 상황일 것임.
  - 즉 T1 쓰기 → T2 읽기이면 가능
- T1 읽기 → (T1 쓰기 or T2 읽기) → T2 쓰기처럼 중간이 겹치는 경우
  - 이 때는 T1 쓰기 집합과 T2 읽기 집합이 안겹쳐야 함
- T1 읽기 → T2 읽기 → (T1 쓰기 or T2 쓰기)인 경우
  - T2 쓰기 집합이 T1 읽기와 쓰기 집합 모두와 겹치지 않아야 함.
  - 먼저 T2의 쓰기가 T1이 읽었던 데이터를 바꾸지 않아야 하고
  - T2가 T1이 썼던 데이터를 덮어쓰지 않아야 함
  - 이때 T1 T2 읽기 관계가 확정되지 않으면 기준이 애매해짐 → 가령 T2 T1 읽기 순서라고 해보자. 그러면 T2의 쓰기 집합은 T1과 충돌이 없었지만 반대로 T2에서 읽은 데이터가 T1의 쓰기 집합과 충돌할 수 있음. 그래서 읽기 순서를 지정한 것
- 이렇게 세 케이스에서 직렬 가능성 보장하고, 커밋될 수 있음

이 방식은 검증이 대부분 성공하여 트랜잭션을 재시도할 필요가 없을 때 효율적인데, 재시도는 성능에 상당히 부정적인 영향을 주기 때문입니다. 물론 낙관적 동시성 제어에도 트랜잭션이 한 번에 하나씩만 진입할 수 있는 임계 구역이 존재합니다. 일부 연산에 대해 비배타적 소유권을 허용하는 또 다른 방법은 독자에게 공유 접근을 허용하는 readers-writer 잠금과 필요할 때 공유 잠금을 배타 잠금으로 변환할 수 있는 업그레이드 가능한 잠금을 사용하는 것입니다.

- OCC는 충돌이 발생할 가능성이 낮아야 효과적임. 즉 대부분의 검증이 성공해야 함. 왜? 그래야 재시도를 안하니까. 재시도를 많이하면 성능에 매우 안 좋음.
- OCC도 임계 구역이 필요함. 검증 / 쓰기가 원자적이어야 하기 때문. 즉 완전히 락이 필요하지 않은 건 아님. 하지만 앞에서 말했듯이 읽기 단계에 비해서는 짧기 때문에 괜찮다는 것
- 일부는 락을 안 잡게 하는 방법도 있음. (뒤에서 나옴)
  - readers-writer 락 → reader가 접근을 공유할 수 있음
  - upgradable 락 → 필요할 때 공유 락을 배타 락으로 바꿀 수 있음

## Multiversion Concurrency Control

다중 버전 동시성 제어(multiversion concurrency control)는 데이터베이스 관리 시스템에서 여러 레코드 버전을 허용하고 단조 증가하는 트랜잭션 ID나 타임스탬프를 사용함으로써 트랜잭션 일관성을 달성하는 방법입니다. 이는 새로운 값이 커밋될 때까지 읽기 연산이 계속해서 이전 값을 접근할 수 있으므로 저장소 수준에서 최소한의 조정으로 읽기와 쓰기 연산이 진행될 수 있게 합니다.

- 각 트랜잭션이 자신만의 스냅샷을 가짐 (앞에서 repeatable read / phantom read 방지한다고 했었음)
- 단조증가 ID or 타임 스탬프 → 버전 간 시간 선후관계 명확하게 하기 위함. 왜 명확해야 하는가? 그건 과거부터 현재까지의 버전을 봐야하기 때문임.
- “새로운 값이 커밋될 때까지 읽기 연산이 계속해서 이전 값을 접근할 수 있으므로” → 새로운 트랜잭션의 쓰기가 발생하더라도 커밋되기 전까지는 이전 값으로 스냅샷을 따감. 커밋된 이후에야 새로운 값으로 스냅샷을 땀.
- “저장소 수준에서 최소한의 조정으로 읽기와 쓰기 연산이 진행될 수 있게” → 기존에는 락으로 인해 읽기와 쓰기가 서로를 기다리거나 막아야 했음. 즉 내가 A를 A*로 쓰고 싶다면 A에 락을 걸고 읽기를 막아야 했음. 하지만 MVCC에서는 내가 A를 A*로 만들면서도 다른 트랜잭션이 A를 자유롭게 읽을 수 있음. 애초에 이 값을 스냅샷으로 따가기 때문임.

MVCC는 커밋된 버전과 커밋되지 않은 버전을 구분하며, 이는 각각 커밋된 트랜잭션과 커밋되지 않은 트랜잭션의 값 버전에 대응합니다. 값의 마지막으로 커밋된 버전이 현재 버전으로 간주됩니다. 일반적으로 이 경우 트랜잭션 관리자의 목표는 동시에 최대 하나의 미커밋 값을 유지하는 것입니다.

- 버전을 커밋된 버전 / 커밋되지 않은 버전으로 구별함. 즉 하나의 데이터에 대하여 두 가지 상태가 존재할 수 있음. 커밋된 버전과 미커밋 버전.
- 아까 전에 A를 A*로 만드는 비유를 들었는데, A를 커밋된 버전이라고 할 수 있고 A*를 미커밋 버전이라 할 수 있음. 커밋된 버전은 새로운 트랜잭션은 이 커밋된 버전을 기준으로 스냅샷을 따감
- “값의 마지막으로 커밋된 버전이 현재 버전으로 간주됩니다.” → 커밋된 버전이 당연히 여러 개일 수 있음. 앞서서 우리가 스냅샷에 단조 증가 키나 타임스탬프를 사용한다고 했는데, 이 중 가장 최근에 커밋된 버전(latest)를 현재 버전으로 취급함. 이를 위해서 단조 증가 키와 타임스탬프를 썼던 것. 그래야 시간적 선후관계가 확실하니까.
- “일반적으로 이 경우 트랜잭션 관리자의 목표는 동시에 최대 하나의 미커밋 값을 유지하는 것입니다.” → 쓰기-쓰기 충돌을 방지하기 위함. 가령 A → A\* 와 A → A\*\* 과 같이 미커밋 버전이 2개 생긴다고 해보자. 그러면 어떤 것이 최종본으로 커밋되어야 하는지 어려워짐. 즉 갱신 분실 문제 발생 가능. 따라서 하나의 트랜잭션이 하나의 미커밋 버전만을 만들게 하는 것.

데이터베이스 시스템이 구현한 격리 수준에 따라 읽기 연산이 미커밋 값을 접근할 수 있도록 허용될 수도 있고 허용되지 않을 수도 있습니다 [WEIKUM01]. 다중 버전 동시성은 잠금, 스케줄링, 충돌 해결 기법(예: 2단계 잠금) 또는 타임스탬프 정렬을 사용하여 구현될 수 있습니다. MVCC의 주요 사용 사례 중 하나는 스냅샷 격리 구현입니다 [HELLERSTEIN07].

- DBMS에 격리 수준에 따라 미커밋 데이터 접근에 대한 허용 여부가 달라짐.
- 앞에서 다뤘듯 Read Uncommitted에서는 더티 리드, 즉 모든 미커밋 데이터를 읽는 것이 허용됨. Repeatable Read나 Serializable 등에서는 이런 것들이 금지됨.
- MVCC에는 다양한 기법이 쓰임.
  - 타임스탬프 정렬 → 트랜잭션과 데이터 버전에 타임스탬프를 통해서 시간적 선후관계를 정하고, 최신 버전을 선택하는 방법.
  - 락 (2PL) → MVCC도 부분적으로 락을 사용함. 가령 이전에 쓰기-쓰기 충돌(A→A\*, A→A\*\*) 경우에서 하나의 트랜잭션만이 미커밋 버전을 만들게 해야 하는데, 이때 짧은 락을 거는 방식이 가능함.
  - 스케쥴링 → 트랜잭션의 작업 순서나 충돌 상황에서 어떻게 할지 (트랜잭션을 대기시킬지, 실패하고 롤백시킬지) 를 결정하는 법
- 스냅샷 격리 기능을 구현하기 위해서는 MVCC가 활용됨. 스냅샷 격리의 경우 트랜잭션을 실행하는 내내 고정된 시점의 스냅샷 세계만을 보장하는 방식. 스냅샷 격리는 전 주에 다뤘었음

## Pessimistic Concurrency Control

비관적 동시성 제어 기법은 낙관적 기법보다 더 보수적입니다. 이러한 기법은 트랜잭션이 실행 중일 때 충돌을 탐지하여 그 실행을 차단하거나 중단합니다.

가장 단순한 비관적(락 프리) 동시성 제어 기법 중 하나는 타임스탬프 순서 방식으로, 각 트랜잭션이 타임스탬프를 가집니다. 트랜잭션 연산을 실행할 수 있는지 여부는 더 이른 타임스탬프를 가진 트랜잭션이 이미 커밋되었는지에 따라 결정됩니다. 이를 위해 트랜잭션 관리자는 동시 실행되는 트랜잭션의 읽기 및 쓰기 연산을 나타내는 max_read_timestamp와 max_write_timestamp를 값마다 유지해야 합니다.

- 타임스탬프 오더링이라는 방법이 있음 (락을 사용하지 않음)
  - 트랜잭션마다 타임스탬프를 부여함
  - 먼저 실행된 트랜잭션이 이미 커밋되었는지 여부에 따라 대상 연산 실행 여부 결정함.
  - 각 값에 대하여 max_read_timestamp (가장 최근에 읽은 시각, MRT) / max_write_timestamp (가장 최근에 쓴 시각, MWT)을 유지함

타임스탬프가 max_write_timestamp보다 작은 값에 대해 읽기 연산을 시도하면 이미 더 최신 값이 존재하므로 해당 트랜잭션은 중단되며, 이를 허용하면 트랜잭션 순서를 위반하게 됩니다.

이와 비슷하게, 타임스탬프가 max_read_timestamp보다 작은 쓰기 연산은 더 최근 읽기와 충돌하므로 허용되지 않습니다. 그러나 타임스탬프가 max_write_timestamp보다 작은 쓰기 연산은 허용되는데, 오래된 쓰기 값을 무시해도 안전하기 때문입니다. 이 가정을 토머스 쓰기 규칙이라 부릅니다. 읽기나 쓰기 연산이 수행되면 대응되는 최대 타임스탬프 값이 즉시 갱신됩니다. 중단된 트랜잭션은 새 타임스탬프로 재시작하는데, 그렇지 않으면 다시 중단될 것이기 때문입니다.

- 타임스탬프 오더링의 충돌 판정
  - 읽기 충돌 → t < MWT인 경우. 즉 현재 이 데이터를 읽는 시점이 해당 데이터가 마지막으로 쓰여진 시점보다 과거라면, 이미 새로운 값으로 덮어씌워졌으므로 중단.
  - 쓰기 충돌 → t < MRT인 경우. 즉 현재 이 데이터를 쓰는 시점이 해당 데이터를 마지막으로 읽는 시점보다 과거라면, 자신이 데이터를 쓰기 전에 누군가가 이 데이터를 읽어갔다는 뜻임. 원래였다면 자신이 데이터를 쓴 후에 그 값을 읽어갔어야 했는데, 그렇지 않게 된 것이므로 중단
  - 토머스 쓰기 규칙 → t < MWT인 경우. 즉 현재 이 데이터를 쓰는 시점이 해당 데이터를 마지막으로 쓴 시점보다 과거인 경우. 이는 그냥 예전에 쓴 기록임. 어차피 나중에는 덮어쓰여질 기록. 그래서 중단 시키는 대신, 그냥 무시해버림. 어차피 최신 값으로 덮여쓰여질 것이기 때문에 불필요하게 롤백해봤자 비효율적이라는 것.
- 읽기 쓰기 연산 이후해당 MRT, MWT 값을 즉시 갱신함.
- abort 이후에는 새로운 타임스탬프를 부여해야함. 그렇지 않으면 똑같은 문제 다시 발생

## Lock-Based Concurrency Control

락 기반 동시성 제어 기법은 타임스탬프 순서와 같은 프로토콜이 스케줄을 해결하는 대신 데이터베이스 객체에 대한 명시적 락을 사용하는 비관적 동시성 제어 방식입니다. 락 사용의 단점 중 일부는 경합과 확장성 문제입니다 [REN16].

가장 널리 사용되는 락 기반 기법 중 하나는 투페이즈 락킹(2PL)으로, 이는 락 관리를 두 단계로 분리합니다:

증가 단계(확장 단계라고도 함)에서는 트랜잭션이 필요로 하는 모든 락을 획득하고 어떤 락도 해제하지 않습니다.

축소 단계에서는 증가 단계 동안 획득한 모든 락을 해제합니다.

이 두 정의에서 따르는 규칙은 트랜잭션이 한 개라도 락을 해제한 이후에는 더 이상 어떠한 락도 획득할 수 없다는 것입니다. 2PL이 이러한 단계들 동안 트랜잭션의 작업 실행을 금지하는 것은 아니지만, 보수적 2PL과 같은 일부 2PL 변형은 이러한 제한을 부과하기도 합니다.

- 앞서 본 PCC 방식은 락-프리 방식이라고 했었음. 값에 대하여 MWT와 MRT를 부여하여, 읽기 / 쓰기 연산을 수행할 때마다 쓰는 시점과의 비교를 통해 충돌 여부를 감지하는 방식. 이를 통해서 트랜잭션을 어떻게 인터리빙하여 실행할지 (즉 스케줄을 어떻게 짤 지) 결정할 수 있음.
- 9주차에서 2PL에 대해 이야기하면서 직렬 가능 스케줄을 판단하는 것은 NP-Complete 문제이기 때문에 2PL 같은 방식을 통해 애초부터 직렬 가능하게 만들어질 수밖에 없도록 하는 방식을 채택한다고 했었음
- 2PL은 락을 계속해서 잡는 단계 (증가 단계)와 락을 계속해서 해제하는 단계 (축소 단계) 로 구분하여 충돌 상황을 만들지 않음. 어떻게?
  - 2PL이 두 단계로 락을 나누는 것은 다시 말하면 필요한 모든 락을 확보하기 전까지 다른 락들을 해제하지 않겠다 라는 것으로 해석할 수 있음.
  - 이것이 왜 충돌을 만들지 않는가? 충돌이 만들어지는 이유는 결국 특정 값에 대하여 해당 트랜잭션에서 수행해야 할 모든 연산이 끝나지 않은 채로 락이 해제되어 다른 트랜잭션에서 해당 값에 대한 락을 잡아서 참조하기 때문임. 이를 막기 위해서 그 값의 모든 연산이 끝나기 전까지 락을 해제하지 않고 기다리는 것.
- 보수적 2PL → 보통 2PL은 필요할 때마다 락을 잡는 식. 보수적 2PL은 트랜잭션 시작 전부터 어떤 락을 잡을 지 미리 결정한 다음 한번에 락을 잡음. 그 다음 작업을 시작함. 이렇게 하면 데드락을 막을 수 있지만, 필요한 대상을 미리 말아야 하고 전부 선점한 상태에서 시작하기 때문에 병행성이 떨어질 수도 있음.

경고

비슷한 이름에도 불구하고, 투페이즈 로킹은 투페이즈 커밋(“Two-Phase Commit” 참조)과 전혀 다른 개념입니다. 투페이즈 커밋은 분산 다중 파티션 트랜잭션에서 사용되는 프로토콜이고, 투페이즈 로킹은 직렬 가능성을 구현할 때 자주 쓰이는 동시성 제어 메커니즘입니다.

- 2PC는 분산 트랜잭션에서 쓰이는 개념이니 조심…

### Deadlock

잠금 프로토콜에서 트랜잭션은 데이터베이스 객체에 대한 잠금을 획득하려 시도하며, 잠금을 즉시 부여받지 못하면 잠금이 해제될 때까지 대기해야 합니다. 실행을 계속하기 위해 필요한 잠금을 획득하려다 두 트랜잭션이 서로가 보유한 잠금이 해제되기를 기다리게 되는 상황이 발생할 수 있습니다. 이러한 상황을 교착 상태(deadlock)라고 합니다.

그림 5-6은 교착 상태의 예를 보여줍니다: 트랜잭션 T1은 잠금 L1을 보유한 채 잠금 L2가 해제되기를 기다리고, 트랜잭션 T2는 잠금 L2를 보유한 채 L1이 해제되기를 기다립니다.

- T1 : 이미 L1을 획득. 추가 작업 위해 L2 필요 → L2 해제 대기
- T2 : 이미 L2를 획득. 추가 작업 위해 L1 필요 → L1 해제 대기

교착 상태를 처리하는 가장 간단한 방법은 타임아웃을 도입하고 교착 상태에 빠졌을 가능성이 있는 장시간 실행 트랜잭션을 중단하는 것입니다. 또 다른 전략인 보수적 2단계 잠금(conservative 2PL)은 트랜잭션이 어떤 연산도 실행하기 전에 필요한 모든 잠금을 획득하도록 요구하며, 이를 얻지 못하면 중단합니다. 그러나 이러한 접근 방식은 시스템 동시성을 크게 제한하므로, 데이터베이스 시스템은 대개 트랜잭션 관리자를 사용해 교착 상태를 감지하거나(다시 말해 방지)합니다.

- 앞에서 말한 보수적 2PL
  - 트랜잭션 시작 시점에 필요한 모든 락을 선획득
  - 불충분하면 즉시 abort → 교착 상태 원천 차단
  - 단점: 필요 락을 미리 알기 어렵고, 락 보유 시간 증가. 동시성 매우 떨어짐…
  - 그래서 트랜잭션 매니저가 데드락을 감지하거나 방지하는 방식을 채택

교착 상태 감지는 일반적으로 대기 그래프(wait-for graph)를 사용해 수행되며, 이 그래프는 실행 중인 트랜잭션들 사이의 관계를 추적하고 그들 간의 대기 관계를 설정합니다.

이 그래프에 사이클이 존재하면 교착 상태가 발생했음을 의미합니다: 트랜잭션 T1은 T2를 기다리고 있고, T2는 반대로 T1을 기다립니다. 교착 상태 탐지는 주기적으로(일정 시간 간격마다) 또는 지속적으로(대기 그래프가 갱신될 때마다) 수행할 수 있습니다. 두 트랜잭션 중 하나(보통 더 최근에 락을 요청한 트랜잭션)가 중단됩니다. 교착 상태를 피하고 교착 상태를 초래하지 않을 경우에만 락을 획득하도록 제한하기 위해, 트랜잭션 관리자는 트랜잭션 타임스탬프를 사용해 우선순위를 결정할 수 있습니다. 일반적으로 타임스탬프가 낮을수록 우선순위가 높고 그 반대도 마찬가지입니다.

- Waits-for Graph로 표현하여 데드락 판정 가능
  - 간선: Ti가 Tj를 기다리고 있다는 (대기 중인) 상황 가정
  - 이때 사이클이 있다면 데드락 판정임
- 탐지 시점에는 두 가지 있음
  - 주기적 검사(시간 간격마다) → 오버헤드 낮음, 반응 늦음
  - 수시 검사(그래프 변경 시마다) → 빠른 탐지, 비용 증가
- 해결 → 사이클 내 트랜잭션 중 최근 락 요청자 또는 우선순위 낮은 트랜잭션을 선택해 abort 후 재시도.

트랜잭션 T1이 현재 T2가 보유한 잠금을 획득하려 시도하고, T1이 우선순위가 더 높을 경우(즉 T1이 T2보다 먼저 시작했을 때) 교착 상태를 피하기 위해 다음 제약을 사용할 수 있습니다 [RAMAKRISHNAN03].

Wait-die: T1은 잠금이 풀릴 때까지 대기할 수 있으며, 그렇지 않으면 T1은 중단되어 재시작됩니다. 즉, 트랜잭션은 자신보다 타임스탬프가 더 높은 트랜잭션에게만 대기될 수 있습니다.

Wound-wait: T2는 중단되어 재시작됩니다(T1이 T2를 wound 함). 반대로 T2가 T1보다 먼저 시작한 경우에는 T1이 대기하도록 합니다. 즉, 트랜잭션은 자신보다 타임스탬프가 더 낮은 트랜잭션에게만 대기될 수 있습니다.

트랜잭션 처리를 위해서는 스케줄러가 교착 상태를 다뤄야 하지만, 래치(“Latches” 참조)는 교착 상태 회피 메커니즘에 의존하지 않고 프로그래머가 교착 상태가 발생하지 않도록 보장해야 합니다.

- T1이 T2보다 먼저 시작했고 T2 락을 획득하고 싶은 상황에서 데드락을 회피하려면?
- wait-die
  - 말 그대로 기다리거나 죽거나.
  - 요청하는 트랜잭션이 보유 트랜잭션보다 오래됐다면 기다림 → 오래 기다렸으니 우선순위 높음
  - 요청하는 트랜잭션이 보유 트랜잭션보다 젊다면 죽음 (중단 후 재시작) → 우선순위가 낮기 때문
  - 비선점 방식. 즉 실행 중인 젊은 트랜잭션을 오래된 트랜잭션이 강제로 중단시키지 않음.
- wound-wait
  - 상처를 입히거나 기다리거나.
  - 요청 트랜잭션이 오래됐다면 보유 트랜잭션을 중단(wound)시키고 즉시 락 획득 → 오래됐으니 우선순위 높음
  - 반대…

### Locks

두 개의 트랜잭션이 동시에 제출되어 겹치는 데이터 구간을 수정하는 경우, 서로의 부분 결과를 관찰해서는 안 되며 논리적 일관성이 유지되어야 합니다. 마찬가지로 동일한 트랜잭션의 두 스레드는 동일한 데이터베이스 내용을 관찰하고 서로의 데이터에 접근할 수 있어야 합니다.

- 서로 다른 트랜잭션이 같은 레코드‧범위를 동시에 갱신할 때 중간 상태(부분 결과)를 노출하면 논리적 일관성이 깨짐 → 락, MVCC 등으로 부분 결과를 가림.
- 한편 단일 트랜잭션 내부의 파트(스레드)는 공유 스냅샷을 전제로 동작. 하나의 스레드가 쓴 변경 사항을 다른 스레드가 즉시 볼 수 있어야 트랜잭션 원자성 보존.

트랜잭션 처리에서는 논리적 무결성과 물리적 데이터 무결성을 보호하는 메커니즘을 구분합니다. 논리적 무결성과 물리적 무결성을 담당하는 두 개념은 각각 락과 래치입니다. 여기서 래치라고 부르는 것은 시스템 프로그래밍에서 보통 락이라고 불리므로, 명칭이 다소 혼동될 수 있지만 이 절에서 그 구분과 의미를 명확히 하겠습니다.

- DBMS 설계 시 비즈니스 관점 무결성(논리)과 저장구조 관점 무결성(물리) 책임을 나눈다. 각 영역마다 요구 성능·락 범위가 다르므로 별도 체계가 필요
  - Lock: 트랜잭션 수준 동시성 제어.
  - Latch: 내부 자료구조(페이지, 노드) 보호용 경량 동기화.
- OS 영역에서는 mutex/lock 용어 사용 → DB 용어와 상충됨. 문맥에 따라 락이 의미하는 계층이 다르므로 구분이 중요함

락은 겹치는 트랜잭션을 분리하고 스케줄링하며 데이터베이스 내용을 관리하지만 내부 저장 구조는 관리하지 않으며, 키 단위로 획득됩니다. 락은 특정 키(존재 여부와 관계없이) 또는 키 범위를 보호할 수 있습니다. 락은 일반적으로 트리 구현 외부에 저장·관리되며 데이터베이스 락 매니저가 담당하는 상위 개념을 나타냅니다.

락은 래치보다 무거우며 트랜잭션이 종료될 때까지 유지됩니다.

- 락
  - 책임: 트랜잭션 간 충돌 해결(직렬 가능성).
  - 단위: 특정 키/키 범위 → 레코드 수준 격리.
  - 내부 B-Tree 구성요소(페이지 등)를 직접 보호하지 않음.
  - 존재 여부와 관련 없이? → 레인지 락 말하는 것. 이럼 팬텀 리드 막을 수 있음
  - 별도 Lock Table/Manager 구성 → 자료구조와 분리해서 저장하고 관리
  - 수명: `BEGIN … COMMIT/ROLLBACK` 전 구간
    - 반면 래치는 짧은 임계구역만 보호하고 곧바로 해제됨.

### Latches

반면 래치는 물리적 표현을 보호합니다: 삽입, 갱신, 삭제 연산 동안 리프 페이지의 내용이 수정됩니다. 비리프 페이지의 내용과 트리 구조는 리프의 언더플로우와 오버플로우로부터 전파되는 분할 및 병합 연산 중에 수정됩니다. 이러한 연산 동안 래치는 물리적 트리 표현(페이지 내용과 트리 구조)을 보호하며 페이지 수준에서 획득됩니다. 안전한 동시 접근을 위해서는 모든 페이지가 래칭되어야 합니다. 락 없는 동시성 제어 기법도 여전히 래치를 사용해야 합니다.

- 래치는 페이지 자체(물리 구조)를 보호하는 경량 락임
- 앞에서 배운 내용에 따르면…
  - 리프 페이지는 데이터 레코드가 실제 저장되는 위치 → CRUD 시 항상 변경 대상이었음
  - 리프 노드가 가득 차거나 비게 되면 → split / merge 필요.
  - 이 변화가 부모까지 전파되면서 상위 노드도 수정해야 함
- “이러한 연산 동안 래치는 물리적 트리 표현(페이지 내용과 트리 구조)을 보호하며 페이지 수준에서 획득됩니다.” → 페이지 레벨에서 동작하면서 페이지 내 데이터 및 자식 포인터 등을 보호함
- 페이지를 래칭하지 않고 접근하면 경합 상태 빠질 수도 있음. 따라서 선 래치 후 읽기 쓰기 동시 작업해야 함.
- MVCC나 PCT(타임스탬프 오더링)은 락-프리이지만 여전히 페이지 보호 차원에서 래치 필요함. 즉 논리적으로는 락이 필요없지만 물리 계층 보호를 위해 래치를 쓰는 것

리프 수준의 단일 수정이 B-트리의 상위 수준으로 전파될 수 있으므로 래치를 여러 수준에서 획득해야 할 수도 있습니다. 실행 중인 쿼리는 불완전한 쓰기나 부분 노드 분할과 같이 데이터가 원본 노드와 대상 노드에 모두 존재하거나 부모에 아직 전파되지 않은 불일치 상태의 페이지를 관찰해서는 안 됩니다.

- 예: 리프 split → 새 키 부모에 삽입 → 부모 split 가능 → 다단계 래치 체인 필요.
- 보통 하위→상위 순으로 순차 래치하여 데드락 방지.
- 래치 해제 전 상태가 atomic 해야 함. 부분 쓰기, 노드 split 두 페이지에 중복 데이터, 부모 갱신 전 자식 변경 등 → 모두 감춰야 안전. 즉 삽입한다면 삽입 전과 모든 전파가 끝난 후 상태만을 관찰해야.

동일한 규칙이 부모 또는 형제 포인터 업데이트에도 적용됩니다. 일반적인 규칙은 동시성을 높이기 위해 페이지를 읽거나 업데이트할 때와 같이 가능한 가장 짧은 기간 동안만 래치를 보유하는 것입니다.

- 포인터 수정 중간 상태 노출 시 전파가 발생할 수 있으므로 부모와 형제 포인터에도 래칭 필요함.
- 당연히 래치가 길면 성능 상 안 좋으므로 읽고 쓸 때만 래치를 확보하는 것이 좋다

동시 실행되는 작업 간 간섭은 대략 세 가지 범주로 나눌 수 있습니다.

동시 읽기: 여러 스레드가 동일한 페이지를 수정 없이 읽는 경우.

동시 갱신: 여러 스레드가 동일한 페이지를 수정하려 시도하는 경우.

읽기 중 쓰기: 한 스레드가 페이지 내용을 수정하려 하고 다른 스레드가 같은 페이지를 읽으려 하는 경우.

이러한 시나리오는 ‘vacuum and maintenance’에서 설명한 백그라운드 유지 관리 작업과 겹치는 접근에도 동일하게 적용됩니다.

- 동시 읽기
  - 순수 읽기만 발생 → 일반적으로 락 프리 혹은 공유 래치(읽기 래치)로 충분.
  - I/O 캐시 히트율이나 버스 대역폭만 고려하면 됨.
- 동시 갱신
  - 배타 래치 필요. 두 쓰기가 충돌하면 손상 가능.
  - 경합이 심해지면 페이지 단편화·스핀락 대기 시간 증가.
- 읽기 중 쓰기
  - 읽기 스레드가 부분적으로 수정된 데이터를 볼 위험 → 반복 불변식 깨짐.
  - 보통 쓰기 시 배타 래치, 읽기는 쓰기 종료 후 재시도.
- PostgreSQL VACUUM, 체크포인트, 인덱스 재조직 등 시스템 작업도 페이지를 읽고쓰므로, 사용자 쿼리와 동일한 규칙으로 보호되어야 데이터 손상 없이 병행 가능.

### Readers-writer lock

가장 단순한 래치 구현은 요청한 스레드에게 배타적인 읽기·쓰기 접근을 부여합니다. 하지만 대부분의 경우 모든 프로세스를 서로 완전히 격리할 필요는 없습니다. 예를 들어, 읽기 작업은 동시에 페이지에 접근해도 전혀 문제가 없으므로 우리는 단지 여러 쓰기 작업이 겹치지 않도록 하고, 읽기 작업이 쓰기 작업과 겹치지 않도록 보장하면 됩니다. 이러한 세분화 수준을 달성하기 위해 리더-라이터 락(RW 락)을 사용할 수 있습니다. (공유 락 배타 락)

RW 락은 여러 리더가 객체에 동시에 접근하는 것을 허용하고, 보통 더 적은 수인 라이터만 배타적 접근을 획득해야 합니다. 그림 5-7은 리더-라이터 락의 호환성 테이블을 보여주는데, 오직 리더들만 락 소유권을 공유할 수 있고 리더와 라이터의 다른 모든 조합은 배타적 소유권을 획득해야 합니다.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%2010%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2022e998e1b70980c7ae9bffe41c01c402/image.png)

- 기본 형태의 래치는 mutual exclusion만 제공함. 어떤 스레드가 래치를 잡으면 그동안 다른 스레드는 읽기조차 불가함
- 실제 워크로드에서는 읽기 비중이 높음. 불필요한 배타 구간이 많으면 동시성, 성능 낮아지는 현상 발생함
- “예를 들어, 읽기 작업은 동시에 페이지에 접근해도 전혀 문제가 없으므로 우리는 단지 여러 쓰기 작업이 겹치지 않도록 하고, 읽기 작업이 쓰기 작업과 겹치지 않도록 보장하면 됩니다.”
  - 읽기-읽기 충돌은 데이터 변형이 없으므로 안전
  - 핵심 보호 대상은
    1. 쓰기↔쓰기 중복 수정 충돌 차단
    2. 읽기↔쓰기 부분 수정 노출 차단
- “이러한 세분화 수준을 달성하기 위해 리더-라이터 락(RW 락)을 사용할 수 있습니다.” → 공유 모드(읽기)와 배타 모드(쓰기)를 구분해 허용. 읽기 중심 시스템에서 락 대기 시간 극적으로 단축 가능함
- “RW 락은 여러 리더가 객체에 동시에 접근하는 것을 허용하고, 보통 더 적은 수인 라이터만 배타적 접근을 획득해야 합니다.”
  - Reader → Shared lock : 동시 진입 가능
  - Writer → Exclusive lock : 단일 진입, 모든 리더·라이터 배제
- “그림 5-7은 리더-라이터 락의 호환성 테이블을 보여주는데, 오직 리더들만 락 소유권을 공유할 수 있고 리더와 라이터의 다른 모든 조합은 배타적 소유권을 획득해야 합니다”.
  - R + R → 허용
  - R + W, W + R, W + W → 불가, 한쪽만 유지

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%2010%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2022e998e1b70980c7ae9bffe41c01c402/image%201.png)

그림 5-8 (a)에서는 여러 개의 리더가 객체에 접근하고 있으며, 라이터는 리더들이 접근하는 동안 페이지를 수정할 수 없으므로 자신의 차례를 기다리고 있습니다. 그림 5-8 (b)에서는 라이터 1이 객체에 대한 전용 락을 보유하고 있고, 다른 라이터 하나와 세 개의 리더는 대기해야 합니다. 그림 5-8. 리더-라이터 락 동일한 페이지에 접근하려는 두 개의 중첩된 읽기 작업은 페이지 캐시가 디스크에서 페이지를 두 번 가져오는 것을 방지하는 것 외에는 동기화가 필요하지 않으므로 읽기 작업은 공유 모드에서 안전하게 동시에 실행될 수 있습니다. 쓰기 작업이 개입하는 순간부터는 쓰기를 동시 읽기 및 다른 쓰기와 모두 격리해야 합니다.

- a
  - 여러 리더가 동시에 공유 래치를 획득해 페이지를 읽고 있음
  - 라이터는 배타 래치가 필요하지만 현재 얻을 수 없어 대기 중
  - 왜? 리더가 페이지를 점유하는 동안 라이터가 수정하면 일관성 깨짐.
- b
  - 라이터 1이 이미 배타 래치를 가지고 페이지를 수정하는 중
  - 추가 라이터와 3개의 리더는 락 충돌 때문에 큐에서 대기
  - 왜? 라이터 간에도 동시 수정 방지를 위해 오직 하나만 허용
- 읽기-읽기 충돌 없음 → 데이터 변형 X.
  - 실제 동기화 비용: 디스크-메모리 캐시 중복 I/O만 주의
  - 공유(Shared) 래치로 다중 리더를 허용해도 안전하고 효율적
- 쓰기-읽기 충돌: 부분 수정 노출 위험.
  - 쓰기-쓰기 충돌: 데이터 손상 가능.
  - 라이터 진입 시 배타(Exclusive) 래치로 전체 차단 → 원자적 업데이트 보장

### Latch crabbing

래치를 획득하는 가장 단순한 방법은 루트에서 대상 리프까지 가는 동안 모든 래치를 한꺼번에 잡는 것입니다. 이는 동시성 병목을 만들기 때문에 대부분의 경우 피할 수 있습니다. 래치를 보유하는 시간은 최소화해야 합니다. 이를 달성하기 위해 사용할 수 있는 최적화 중 하나를 래치 크래빙(또는 래치 커플링)이라고 합니다.

- 루트→리프 경로의 모든 페이지를 한꺼번에 배타적으로 잠그는 방식
  - 장점: 구현이 쉽고 안전.
  - 단점: 경로를 공유하는 다른 스레드가 전부 대기 → 심각한 병목.
- 전체 트리 작업이 직렬화되어 처리량 저하.
  - 래치는 짧은 임계구역 보호용 → 길게 잡으면 경합 커짐
  - 따라서 필요한 순간에만 잠그고 즉시 해제해야 함 → 래치 크래빙

래치 크래빙은 실행 중인 연산이 더 이상 래치를 필요로 하지 않다는 것이 명확해지는 즉시 래치를 더 짧은 시간 동안만 보유하고 해제할 수 있게 해 주는 매우 간단한 방법입니다. 읽기 경로에서는 자식 노드를 찾고 그 래치를 획득하는 즉시 부모 노드의 래치를 해제할 수 있습니다.

- 어떻게?
  - 자식 페이지 래치를 획득
  - 부모 페이지 래치를 즉시 해제
  - 이후 탐색/수정은 자식에서 반복
  - 따라서 경로상 동시에 한 페이지만 배타적 래치 → 경합 최소화됨
- 읽기 경로
  - 읽기는 구조 변경 X → 자식 페이지 도달 후 부모 보호 불필요함.
  - 탐색 중 페이지 1개만 잠그므로 다중 스레드 병렬 읽기 가능.

삽입 중에는 그 연산이 상위로 전파될 수 있는 구조적 변경을 일으키지 않는 것이 보장되는 경우 부모 래치를 해제할 수 있습니다. 즉, 자식 노드가 가득 차 있지 않다면 부모 래치를 해제할 수 있습니다.

- 삽입 연산으로 인한 분할이 상위로 전파되지 않는다면 (자식 노드가 아직 가득 차지 않은 상태라면) 부모 래치 해제 가능

이와 유사하게 삭제 시에도 자식 노드에 충분한 요소가 있어 형제 노드 병합을 유발하지 않을 경우 부모 노드의 래치를 해제합니다.

- 삭제도 마찬가지로 병합 연쇄가 발생하지 말아야…

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%2010%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2022e998e1b70980c7ae9bffe41c01c402/image%202.png)

그림 5-9는 삽입 시 루트에서 리프로 내려가는 과정을 보여줍니다:

a) 루트 노드에서 쓰기 래치를 획득합니다.

b) 다음 레벨의 노드를 찾아 그 노드에 쓰기 래치를 획득한 뒤, 구조적 변경 가능성을 확인합니다. 노드가 가득 차 있지 않으므로 부모 래치를 해제할 수 있습니다.

c) 연산은 그다음 레벨로 내려갑니다. 쓰기 래치를 획득하고 대상 리프 노드의 구조적 변경 가능성을 확인한 뒤, 부모 래치를 해제합니다.

→ 부모 래치를 가진 채로 자식의 쓰기 래치를 가지고, 자식이 차있는지 여부를 통해서 부모 래치를 해제할지 결정. 이를 반복

이 방법은 낙관적입니다. 대부분의 삽입·삭제 연산은 여러 레벨 위까지 전파되는 구조적 변경을 일으키지 않기 때문입니다. 실제로 상위 레벨로 갈수록 구조적 변경 확률은 감소합니다. 대부분의 연산은 대상 노드에 대해서만 래치가 필요하며, 부모 래치를 유지해야 하는 경우는 상대적으로 드뭅니다. 자식 페이지가 아직 페이지 캐시에 로드되지 않았다면, 앞으로 로드될 페이지에 래치를 걸거나 부모 래치를 해제한 뒤 페이지가 로드된 후 루트-투-리프 패스를 다시 시작해 경합을 줄일 수 있습니다. 루트-투-리프 탐색을 다시 시작하는 것은 비용이 클 것처럼 보이지만, 실제로는 드물게 수행되며 탐색 이후 상위 레벨에서 구조적 변경이 있었는지 여부를 감지하는 메커니즘을 사용할 수 있습니다.

- 보통 분할 합병은 드물기 때문에 낙관적임. 즉 실제로 분할 합병이 발생할 가능성이 있어서 부모까지 래칭해야 하는 경우 드묾.
- 자식이 아직 디스크에 있다면? 그럼 IO 블로킹 생김. 이때 부모가 래칭되었다면 부모를 잠가두지 않고 해제하여, 다른 트랜잭션 진행하는 것도 됨.
- 래치를 놓은 사이 구조가 바뀔 수도 있었기 때문에 다시 루트부터 리프까지 탐색. 비효율적 일 것 같지만 빈도 낮으므로 오버헤드 감수할만함. 또 버전 번호나 LSN 등으로 구조 변경 감지도 가능. 즉 실제로 구조가 바뀌었는지 보고 굳이 재시작하지 않는 것도 가능하다는 것

### Blink-Trees

Blink-Tree는 B\*-Tree(“Rebalancing” 참고)를 기반으로 하여 높은 키(high key)(“Node High Keys” 참고)와 형제 링크 포인터를 추가한 구조입니다. Blink-Tree에서 루트를 제외한 모든 노드는 부모에서 내려오는 자식 포인터와 같은 레벨에 있는 왼쪽 노드로부터 오는 형제 링크 포인터, 이렇게 두 개의 포인터를 가집니다.

- 기존 B\*-Tree에 고키(구간 상한) + 좌측 형제 링크 개념 도입
- 동시성 하에서 구조 변경을 더 유연하게 처리 위함
- 구조
  - 트리-하향 탐색용 child pointer
  - 같은 레벨 좌측 노드가 가리키는 sibling pointer
  - 형제 링크로 “우측 이동” 가능

Blink-Tree는 하프 스플릿(half-split)이라 불리는 상태를 허용하는데, 이 상태에서는 노드가 이미 형제 포인터로 참조되지만 부모의 자식 포인터로는 아직 참조되지 않습니다. 하프 스플릿은 노드의 높은 키를 검사하여 식별합니다. 탐색 키가 노드의 높은 키를 초과해 높은 키 불변 조건을 위반하면, 탐색 알고리즘은 구조가 동시에 변경되었다고 판단하고 형제 링크를 따라 탐색을 계속합니다.

- 새 노드가 형제 링크에는 연결되었지만 부모 포인터는 미등록. 즉 분할이 “절반만 완료”된 상태
- 탐색 키 > 노드 high key → high key 불변식 위배 → half-split 판단

최대 성능을 위해서는 부모에 대한 포인터를 빠르게 추가해야 하지만, 모든 요소에 접근할 수 있으므로 탐색 과정을 중단하거나 다시 시작할 필요는 없습니다. 이점은 자식이 분할될 상황이라 해도 자식 레벨로 내려갈 때 부모 락을 유지하지 않아도 된다는 것입니다. 형제 링크를 통해 새 노드를 가시화하고, 부모 포인터는 늦게 업데이트해도 정확성을 해치지 않습니다.

- 새 노드 먼저 형제 링크로 노출 → 부모 수정은 후처리. 락 보유 시간 최소화
- 대신 추가 I/O 1회 → 하지만 성능 영향 경미(분할 드물기 때문)

이는 부모로부터 바로 내려가는 것보다 페이지를 하나 더 접근해야 하므로 약간 비효율적이지만, 올바른 루트-투-리프 하향 탐색을 보장하면서 동시 접근을 단순화합니다. 분할은 비교적 드문 작업이고 B-Tree는 거의 축소되지 않으므로 이 경우는 예외적이며 그 비용은 무시할 만합니다. 이 방법은 경합을 줄이고, 분할 중 부모 락 보유를 방지하며, 트리 구조를 수정할 때 보유해야 하는 락 수를 상수로 제한한다는 이점이 있습니다. 더 중요한 것은 구조적 트리 변경과 동시에 읽기를 허용하고, 부모 노드로 거슬러 올라가는 동시 수정에서 발생할 수 있는 데드락을 방지한다는 점입니다.

- 부모 락을 잡지 않고 구조 변경 → 데드락 예방
- 트리 수정 시 필요한 락 수를 상수(작은 값) 로 제한
- 구조 변경과 동시 읽기 허용 가능
