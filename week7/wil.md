# 고급 백엔드 스터디 7주차

## Rebalancing

일부 B-트리 구현체는 분할 및 병합 연산을 연기하여, 동일 레벨 내에서 요소들을 재균형시킴으로써 그 비용을 상쇄하려고 시도합니다. 즉, 분할이나 병합을 수행하기 전에 더 많이 채워진 노드에서 덜 채워진 노드로 요소를 이동시키는 방식으로 노드 점유율을 향상시키고, 이로 인해 트리의 레벨 수를 줄일 수 있습니다. 이는 잠재적으로 재균형에 대한 유지 관리 비용이 높아질 수 있습니다.

- 일반적으로 B-트리는 꽉 차거나 너무 비었을 때 분할 / 병합을 시도함. 하지만 이는 비용이 비싸고 부모로 전파되므로 트리 구조에 많은 변경을 가함. 따라서 자주 발생하면 좋지 않음.
- 일부 비트리 구현체는 이러한 분할 병합 연산을 ‘가능한 한 늦게’ 시도, 즉 연기하려고 함
- 어떻게? → 같은 레벨에 있는 여러 노드에 대해서, 더 많이 차있는 노드에서 덜 차있는 노드로 원소들을 이동시키는 방식으로. 이걸 리밸런싱이라고 함.
    - 새로운 노드를 만들고 부모를 갱신하고 키를 수정하는 등등 비용이 비싼 분할 병합에 비하면, 리밸런싱은 요소만 이동시키면 되기 때문에 비용이 저렴함
    
- 이렇게 하면 노드 내부 데이터가 차있는 비율, 즉 노드 점유율이 높아짐. 노드 점유율이 높아지면, 같은 데이터를 더 적은 노드로도 저장할 수 있음. 그러면 트리의 높이가 낮아지므로, 검색 성능이 좋아짐.
    - 트리의 높이와 검색 성능의 연관성은 앞선 강의 참고할 것
- 하지만 리밸런싱을 하면 ‘크게, 가능한 한 늦게’ 하는 것과 다르게 ‘작게, 자주’ 하므로, 이에 대한 비용, 책에서는 ‘메인터넌스(유지보수)’ 비용이 발생할 수 있음.

삽입 및 삭제 연산 중에 로드 밸런싱(load balancing)이 수행될 수 있습니다 [GRAEFE11]. 공간 활용도를 향상시키기 위해, 오버플로우가 발생했을 때 노드를 즉시 분할하는 대신 일부 요소를 형제 노드로 이동시켜 삽입 공간을 확보할 수 있습니다. 마찬가지로 삭제 시에도 형제 노드를 병합하기보다는 일부 요소를 인접한 노드로부터 이동시켜 노드가 최소한 절반 이상 차 있도록 유지할 수 있습니다.

- 리밸런싱 중에서, 삽입 / 삭제 중에 실행하는 ‘로드 밸런싱’이라는 것도 있음
    - 로드 밸런싱은 삽입으로 인한 분할 상황에서 바로 분할하지 않고 늦추기 위해 더 많이 차있는 노드 → 덜 차있는 ‘형제 노드’로 이동시키는 방식
    - 삭제 시 병합 상황에서도 바로 병합하지 않고 형제 노드로부터 일부 요소를 가져와서 최소 절반 이상 차있게 유지 → Ceil(M/2), M = fanout
        - 4주차 B-Tree Node Merges 참고

B*-트리는 두 형제 노드가 모두 가득 찰 때까지 데이터를 분산시킵니다 [KNUTH98]. 이후에는 하나의 노드를 두 개의 반쯤 찬 노드로 분할하는 대신, 두 개의 노드를 세 개의 노드로 분할하고 각 노드는 2/3 정도 차도록 합니다. SQLite는 이 방식을 구현에 사용합니다. 이 접근 방식은 분할을 지연시켜 평균 점유율을 높이고, 결과적으로 검색 성능을 향상시킵니다. 왜냐하면 트리의 높이가 낮아지고, 검색 시 거쳐야 하는 페이지 수가 줄어들기 때문입니다.

- B*-트리도 비슷하게 로드 밸런싱을 수행함. 하지만 분할에 대해서만 키를 나눠주는 재분배 방식을 사용하요, 병합 시에는 다른 B 트리와 동일하게 수행
    - 먼저 대상 노드가 찰 때마다 양 옆의 형제 노드로 재분배하여 분할을 지연시킴
    - 이제 양 쪽이 전부 꽉 차게 된다면, 기준 노드와 형제 노드 중 하나를 골라서 2개를 3개로 분할시킴 (특이하게도, 기준 노드만 분할하는 게 아님)
    - 그러면 2/3만큼 차게 됨 → 최소 자식 노드 제약조건이 Ceil(M/2)에서 Ceil(2M/3)이 됨

Figure 4-9는 좌측 형제 노드가 우측보다 더 많은 요소를 포함하고 있을 때, 두 노드 간에 요소를 분산시키는 모습을 보여줍니다. 점유율이 높은 노드에서 점유율이 낮은 노드로 요소를 이동시키는 방식입니다. 이 과정에서 형제 노드 간의 최소/최대 경계 조건(min/max invariant)이 변경되므로, 부모 노드의 키와 포인터도 이를 반영하여 갱신해야 합니다.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%207%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2021b998e1b70980cc8f40e4cc04735ca3/image.png)

- 재분배를 하게 되면 같은 레벨에서 샥샥 바꾸기 때문에 괜찮지 않을까? 싶겠지만, 당연히 부모 노드의 키 배열도 영향을 받음
- 사진을 보면 10 13 16이 꽉 차서 18 쪽으로 재분배를 해줬음. 그러니까 부모 노드도 변경이 발생한 것을 확인할 수 있음

로드 밸런싱은 많은 데이터베이스 구현에서 유용한 기법입니다. 예를 들어 SQLite는 이 섹션에서 설명한 방식과 유사한 balance-siblings 알고리즘을 구현하고 있습니다. 로드 밸런싱은 구현 복잡도를 높일 수 있지만, 사용되는 상황이 제한적이므로 나중에 최적화로 구현할 수 있습니다.

- 다양한 DBMS에서 로드 밸런싱 기법을 사용 → SQLite는 이와 유사한 balance-siblings 알고리즘 구현
    - balance-siblings : 형제 노드 존재 시 재분배 시도하고, 2→3 분할 수행
    - TODO: 시간 나면 실제 구현 확인해보기
- 당연히 구현 복잡성이 없진 않음
    - 노드 점유율을 계속 계산해야 하고
    - 재분배 이후 부모 키도 갱신해줘야 함
- 그래서 항상 필요한 기능은 아님 → 기본 동작(바로 분할 / 병합), 이후 추가적인 최적화 레이어에서 수행하는 방식으로 고려

## Right-Only Appends

많은 데이터베이스 시스템은 기본 인덱스 키로 자동 증가하는 단조 증가 값(monotonically increasing value)을 사용합니다. 이러한 경우에는 모든 삽입이 인덱스의 끝부분(오른쪽 리프 노드)에서 발생하므로, 대부분의 분할은 각 레벨에서 가장 오른쪽 노드에서 발생합니다. 또한, 키가 단조 증가하므로 삽입이 갱신이나 삭제보다 상대적으로 적게 발생하는 경우, 비리프(nonleaf) 페이지는 무작위로 정렬된 키를 사용하는 경우보다 단편화가 적습니다.

- 많은 DBMS는 인덱스 키로 자동 증가(auto-incremented)하는 단조 증가 값(1, 2, 3, …)을 사용
- B-트리에서 키는 정렬된 순서로 저장되므로, 큰 키일수록 오른쪽으로 향하게 됨. 삽입 역시 오른쪽 리프 노드에서만 발생하게 되어, 분할 역시 오른쪽에서 발생
- 키가 단조 증가하므로 삽입이 갱신이나 삭제보다 상대적으로 적게 발생하는 경우, 비리프(nonleaf) 페이지는 무작위로 정렬된 키를 사용하는 경우보다 단편화가 적습니다.”
    - 키가 단조 증가 → 분할 케이스에서, 중간 키가 승격되어 부모에 영향을 주더라도, 이 키는 가장 오른쪽에 추가됨. 왜? 여전히 부모 노드에서는 이 중간 키가 가장 큰 값이기 때문. 그래서 각 레벨의 비단말 노드는 항상 왼쪽에서 오른쪽으로 채워짐. 또한, 왼쪽 / 중간 서브트리들은 삽입으로부터 영향을 받지 않는다는 장점도 있음. 예시를 보자
        
        ```markdown
        // 1단계 - 3 삽입
        
        [Root/Leaf: 1, 2, 3]  <-- 꽉 참
        
        // 2단계 - 4 삽입
        
              [P: 3]  (새로운 Root, 비리프 페이지)
                |
           +----+----
           |         |
        [L: 1, 2]  [L: 3, 4]
        
        // 3단계 - 5 삽입
        
              [P: 3]
                |
           +----+----
           |         |
        [L: 1, 2]  [L: 3, 4, 5]  <-- 오른쪽 리프가 꽉 참
        
        // 4단계 - 6 삽입
        
                [P: 3, 5]  <-- 비리프 페이지가 왼쪽부터 차곡차곡 채워짐
                  |
           +------+------+-
           |      |        |
        [L: 1, 2] [L: 3, 4] [L: 5, 6]
        
        // 5단계 - 7, 8 삽입
        
                  [P: 3, 5, 7]  <-- 비리프 페이지도 꽉 참
                     |
           +---------+---------+-- ...
           |         |         |
        [L: 1, 2] ... [L: 5, 6] [L: 7, 8]
        
        // 6단계 - 9, 10 삽입
        
                      [P: 7]  (새로운 Root)
                        |
                   +----+----
                   |         |
              [P: 3, 5]     [P: 9]
                 |             |
           +--- ... ---+     +--- ...
           |           |     |
        [L: 1,2] ... [L: 5,6] [L: 7,8] ...
        ```
        
    - 삽입이 갱신이나 삭제보다 상대적으로 적게 → 삽입이 발생하더라도 위에서 말했듯 중간에서 페이지를 분할시키지 않기 때문에 단편화를 발생시키지 않음. 근데 삽입 비중이 갱신 / 삭제보다 낮다면? 더 단편화가 드물게 발생. 갱신은 키 값을 바꾸지 않는 한 그대로 남고, 삭제는 틈을 만들긴 하지만 분할만큼 단편화를 직접적으로 유발시키지도 않으며 심각하지도 않음.
        - [https://www.sqlservercentral.com/articles/understanding-curd-operations-on-tables-with-b-tree-indexes-page-splits-and-fragmentation](https://www.sqlservercentral.com/articles/understanding-curd-operations-on-tables-with-b-tree-indexes-page-splits-and-fragmentation) → “따라서 삭제는 페이지 분할을 직접적으로 유발하지는 않지만, 다른 인덱스가 향후 사용할 수 있는 갭을 생성하여 조각화를 유발할 가능성이 있습니다. 하지만 삽입 및 업데이트로 인해 발생하는 조각화만큼 심각하지는 않습니다.”
        - [https://www.percona.com/blog/illustrating-primary-key-models-in-innodb-and-their-impact-on-disk-usage/](https://www.percona.com/blog/illustrating-primary-key-models-in-innodb-and-their-impact-on-disk-usage/) → auto increment PK가 uuid와 같은 랜덤 PK에 비해 분할을 발생시키지 않는다는 글

PostgreSQL은 이 경우를 fastpath라고 부릅니다. 삽입된 키가 오른쪽 끝 페이지의 첫 번째 키보다 크고, 그 페이지가 새로운 항목을 담을 만큼 충분한 공간을 가지고 있다면, 새로운 항목은 캐시에 있는 오른쪽 리프에 적절한 위치에 삽입되며, 전체 읽기 경로(read path)는 건너뛸 수 있습니다.

- PostgreSQL은 이러한 단조 자동 증가 키가 삽입될 때 발생하는 빠른 처리 경로를 fastpath라고 부름.
    - 새로운 키가 현재 B 트리 상의 가장 오른쪽 리프 노드의 ‘첫 번째 키’보다 커야 함 → 왜 ‘마지막 키’가 아니지?
    - 리프 노드에서 삽입 여부를 결정하기 위해서 첫 번째 키를 비교 기준으로 쓰기 때문이고, DB는 페이지 단위, 즉 노드 단위로 읽기 때문임.
        
        ```markdown
               [50]   
              /    \
          [10 20]  [60 70 90]
        ```
        
        - 여기서 65를 넣는다고 해보자.
        - 그러면 50 오른쪽을 타고 내려와서 → 60보다 작으면 첫 번째로 커지는 값이므로 여기에 삽입 결정. 더 크다면 오른쪽으로 이동하면서 계속 삽입 위치를 찾는다.
    - 실제로 fastpath를 쓰는 경우를 상상해보자.
        - fastpath에서는 가장 오른쪽 노드의 첫 번째 키 60을 캐싱해두고 있을 것.
        - 그러면 65가 들어온다고 했을 때 → 60보다 작다면 fastpath 조건을 충족시키지 못함. 60보다 크다면? 일단 조건 충족 했으니 지름길로 와서 해당 페이지 시작부터 비교 진행. 물론 제일 오른쪽에 들어간다는 보장은 없음. 하지만 루트부터 이 오른쪽 끝 리프까지의 탐색 비용을 줄일 수 있다는 장점 있음 (전체 read path 스킵)
    - https://github.com/postgres/postgres/blob/master/src/backend/access/nbtree/README
        
        > **[fastpath 인덱스 삽입]**
        > 
        > 
        > **증가하는 인덱스 키 값의 삽입이라는 일반적인 경우를 최적화하기 위해, 이 백엔드가 마지막 값을 삽입한 페이지가 가장 오른쪽 잎 페이지인 경우 해당 페이지를 캐시합니다.** 
        > 
        > 다음 삽입 시에는 캐시된 페이지가 여전히 가장 오른쪽 리프 페이지인지, 그리고 현재 값을 저장할 적절한 위치인지 빠르게 확인할 수 있습니다. 이러한 일반적인 경우에서 트리를 탐색하는 비용을 피할 수 있습니다.
        > 
        > 이 최적화는 B-트리에서 가장 오른쪽 리프 페이지가 단 하나만 존재한다는 가정 하에 작동합니다. 따라서 모든 사용자에게 가시적인 상호 잠금 메커니즘이 필요하지 않습니다. 힌트가 무효화되었음을 감지하지 못하는 경우는 없습니다. B-트리에는 언제나 단 하나의 그런 페이지만 존재하기 때문입니다.
        > 
        > 백엔드의 캐시된 페이지가 무효화되지 않은 채로 페이지가 삭제되고 재사용될 수는 있지만, 이는 우연히 다시 가장 오른쪽 잎 페이지로 재사용되는 블록을 재사용할 때만 발생합니다.
        > 

SQLite에도 유사한 개념이 있으며 이를 quickbalance라고 부릅니다. 항목이 가장 오른쪽 끝에 삽입되고 대상 노드가 가득 찬 경우(즉, 삽입 후 그 항목이 트리 내에서 가장 큰 항목이 되는 경우), 노드를 재조정하거나 분할하는 대신 새로운 오른쪽 끝 노드를 할당하고 그 포인터를 부모 노드에 추가합니다(밸런싱 구현에 대한 자세한 내용은 “Rebalancing” 참조). 이렇게 하면 새로 생성된 페이지가 거의 비어 있게 되지만(노드 분할의 경우 절반만 차는 것과는 대조적), 해당 노드는 곧 가득 차게 될 가능성이 높습니다.

- SQLite 역시 fastpath와 비슷한 최적화 기법인 quickbalance가 있음 → 자동 단조 증가 키가 삽입될 때 성능을 높이기 위함
    - 조건
        - 삽입하려는 키가 가장 오른쪽 끝에 삽입될 예정(즉 삽입 대상이 가장 큰 값이 되고)
        - 근데 그 노드 (가장 오른쪽 끝에 있는) 가 꽉 차있다면? (즉 페이지 오버플로가 마지막 셀 삽입으로 인해서 발생한 것이라면?)
        - → 퀵밸런스 로직으로 분기
    - 앞에서 배웠듯 리밸런싱을 통해 분할하지 않고 왼쪽 형제 노드를 보고 비어있으면 나눠주거나 / 그냥 노드를 분할해서 절반으로 쪼개고, 구분 키를 부모 노드에 추가하는 방식 중 하나를 선택했을 것임
    - 이 두 방식 모두 택하지 않고, 새로운 오른쪽 끝 노드(페이지)를 오른쪽에 만들어서 붙인 다음, 부모 노드와 연결. 이때는 비어있는 페이지
    - 그 다음 우리가 추가하려는 노드를 삽입함. 그러면 딱 하나의 엔트리만 들어간 거의 빈 페이지가 됨
    - 왜 이렇게 할까?
        - 새로 생긴 페이지가 단기적으로는 거의 비어있으므로, 공간이 낭비되는 것처럼 보일 수 있음
        - 하지만 단조 증가 키의 특성에 따라 계속해서 오른쪽으로 삽입이 발생할 것이므로, 장기적으로는 이 페이지는 금방 채워질 것임. 그러면 분할 과정에서 기존 데이터를 복사하는 비용이 발생하지 않음
    - 즉 일시적으로는 공간이 낭비되지만 장기적으로는 시간을 아낄 수 있음

### Bulk Loading

정렬된 데이터를 가지고 있고 이를 벌크 로드하고자 하거나, 트리를 다시 구축해야 하는 경우(예: 단편화 제거를 위해), 우리는 우측 전용 추가(right-only appends) 개념을 더 확장할 수 있습니다. 트리 생성을 위해 필요한 데이터가 이미 정렬되어 있으므로, 벌크 로딩 시에는 항목들을 트리의 가장 오른쪽 위치에 단순히 추가하기만 하면 됩니다.

- 아래 경우에 right-only append (우측 추가) 를 사용 가능
    - 트리 외부에서 데이터를 미리 정렬된 상태로 가지고 있다고 하자. 이 데이터를 삽입할 때 하나씩 처리하지 않고 한꺼번에 처리하는 걸 ‘벌크 로딩’이라고 함
    - 또 기존 트리가 단편화 등으로 인해 비효율적인 경우에 트리를 다시 만들어야 경우 (인덱스 리빌드) 도 있음
- 위에서 논의했던 fastpath 개념으로 맨 오른쪽 리프 노드 페이지에 접근하고, quickbalance 로 페이지를 만든 뒤 엔트리를 추가한다면 매우 간단하게 오른쪽에 추가하는 것이 가능함. quickbalance에서 논의했듯 분할도 회피 가능.

이 경우, 우리는 분할이나 병합을 완전히 피할 수 있으며, 트리를 아래에서부터 위로 구성하면서 계층별로 기록하거나, 이미 기록된 하위 노드에 대한 포인터를 충분히 확보한 즉시 상위 노드를 기록할 수 있습니다.

- 두 가지 방식 가능
    - 리프 채우고 → 내부 채우고 → 루트 순으로 기록하기
        - 피라미트 쌓는 걸 생각하면 될 듯
            
            ```markdown
            ## 0단계
            
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
            
            ## 1단계 -> 리프 페이지 4개로 쪼개기
            
            L1: [1, 2, 3, 4]
            L2: [5, 6, 7, 8]
            L3: [9, 10, 11, 12]
            L4: [13, 14, 15, 16]
            
            ## 2단계 -> 그 다음 레벨 만들기
            
            P1: [ ->L1, (5, ->L2), (9, ->L3) ]  << 용량이 꽉 참
            
            P2: [ ->L4 ]  << 새로운 부모 페이지로 보내기
            
            ## 3단계 -> 그 다음 레벨 (루트) 만들기
            
            Root: [ ->P1, (13, ->P2) ]
            
            ## 결과
                                  +--------------------------+
                                  | Root: [ ->P1, (13,->P2)] |
                                  +--------------------------+
                                     /                    \
                                    /                      \
                 +-----------------------------+         +----------+
                 | P1: [->L1, (5,->L2), (9,->L3)] |      | P2: [->L4] |
                 +-----------------------------+         +----------+
                   /           |           \                   |
                  /            |            \                  |
            +-----------+  +-----------+  +-----------+    +-----------+
            | L1: [1-4] |  | L2: [5-8] |  | L3: [9-12]|    | L4:[13-16]|
            +-----------+  +-----------+  +-----------+    +-----------+
            ```
            
    - 상위 노드 적절히 구성 가능해지면 즉시 기록하기
        - ‘하위 페이지로의 포인터(P)’와 ‘이를 구분하기 위한 키(K)’ 만 충분히 확보된다면, 기록 가능해짐
            
            ```markdown
            ## 1단계
            
            []  // 리프의 부모(L1의 부모)를 만들기 위한 스택 1
            []  // L1 부모의 부모(루트)를 만들기 위한 스택 2
            [1, 2, 3, 4, 5, 6, 7, 8, ..., 16] // 입력값
            
            ## 2단계
            
            [ ->L1 ]             // 1 ~ 4로 L1 만들고 L1 포인터 스택1에 푸시
            [ ->L1, (5, ->L2) ]  // 5 ~ 8로 L2 만들고 (5, ->L2) 쌍 스택2에 푸시
            [ ->L1, (5, ->L2), (9, ->L3)] // 9 ~ 12로 L3 만들고 스택에 푸시
            
            ## 3단계
            
            이때 스택1의 내용으로 부모 페이지 P1을 만들 수 있음!
            플러시 이후 스택은 다시 비워짐
            
            [ ]     // 플러시 이후 스택1은 다시 비워짐
            [ ->P1] // P1이 만들어졌다는 정보를 상위 스택인 스택2에 기록
            
            ```
            
            이런 식으로 기존처럼 L1 ~ L4가 모두 만들어지기를 기다리지 않고, P1을 만들 수 있게 되자마자 만들어버린 뒤 스택을 비우고, 그 결과를 상위 레벨에 기록
            
            그렇다면 ‘만들 수 있게 되자마자’ 의 기준은 뭘까? → 페이지 용량이 기준임. 우리는 위에서 페이지 팬아웃을 3으로 설정했음. 그래서 스택의 크기가 3이 되자마자 새로운 페이지를 만들어버린 것
            
        

벌크 로딩을 구현하는 한 가지 방법은 정렬된 데이터를 리프 수준에서 페이지 단위로 기록하는 것입니다(개별 요소를 삽입하는 방식이 아님). 리프 페이지가 기록된 후에는 그 첫 번째 키를 부모에게 전달하고, 일반적인 알고리즘을 사용하여 상위 B-트리 계층을 구성합니다 [RAMAKRISHNAN03]. 추가된 키들이 정렬된 순서로 주어지므로, 이 경우 발생하는 모든 분할은 가장 오른쪽 노드에서만 일어납니다.

- 벌크 로딩은 정렬된 데이터를 하나씩 넣지 않고, 리프 노드에 페이지 단위로 기록하는 방법
    - 기록 이후 해당 페이지의 첫 번째 키를 부모로 전달 → 이는 부모 노드의 구분 키가 되기 때문임. 이후에는 기존 B-트리 방식대로 진행
    - 이렇게 여러 페이지를 기록한다면, 각각의 리프 페이지의 첫 번째 키 역시 정렬된 순서이므로 부모 노드에서 키의 삽입 역시 정렬된 순서로 발생
    - 그렇다면 우리가 앞에서 논의했던 것처럼 정렬된 삽입 → 항상 오른쪽 노드에서의 분할로 이어짐

B-트리는 항상 아래(리프) 수준부터 구성되므로, 전체 리프 수준을 먼저 기록한 다음 상위 노드를 구성할 수 있습니다. 이로 인해 상위 노드를 구성할 시점에 자식 포인터들을 모두 확보할 수 있습니다. 이 접근 방식의 주요 이점은 디스크에서 어떤 분할이나 병합도 수행할 필요가 없고, 동시에 트리의 일부분(즉, 현재 채우고 있는 리프 노드의 모든 부모)만을 메모리에 유지하면 된다는 점입니다.

- B 트리는 항상 리프 → 내부 → 루트 순으로 만들어짐 (바텀업)
- 따라서 상위 노드를 구성하는 시점에는 항상 해당 노드가 가리킬 자식 포인터들이 존재함 → 즉 모든 정보를 채울 수 있음
- 일반적인 방식에서는 분할 병합이 발생함. 하지만 이러한 바텀업 벌크 로딩은 분할이나 병합 발생하지 않음
    - 왜? 분할 병합은 예측 불가능한 삽입 삭제로 인해서 오버플로 / 언더플로로 인해 → ‘이미 깨진 균형’을 ‘나중에 사후적으로’ 맞추는 작업임
    - 하지만 벌크 로딩은 미리 모든 걸 계획한 상태에서 시작. 페이지를 꽉 채우고 그것만 쓰기 때문에 오버플로 자체가 발생 안함. 데이터 삭제는 없기 때문에 당연히 병합도 없음
- 아까 전 ‘구성 가능해지면 바로 기록하기’ 방식에서 봤듯이 스택에다가 리프 페이지를 기록하고 디스크에 쓴 다음 그 포인터를 메모리 상 스택에 기록함. 스택이 꽉 차면 (즉 페이지에 기록할 수 있게 되면) 부모 페이지로 기록하고 그 포인터를 조부모 페이지에 기록할 스택에 채워둠.
    - 따라서 메모리에 모든 정보를 기록하지 않기 때문에 매우 효율적

불변 B-트리(immutable B-Trees)도 같은 방식으로 생성할 수 있지만, 가변 B-트리와는 달리 이후 수정에 필요한 공간 오버헤드가 없습니다. 트리에 대한 모든 작업이 최종적이기 때문입니다. 모든 페이지를 완전히 채워서 기록할 수 있으므로, 점유율이 향상되어 성능이 더 좋아집니다.

- 불변 B-Tree → 기존 트리 바꾸는 대신 변경된 새로운 버전의 트리를 만듦.
    - 변경되지 않는 부분은 기존 트리의 노드를 그대로 재사용
- 불변 비트리의 초기 생성은 벌크 로딩 방식과 동일함. 이전 버전이 없기 때문에 수정을 고려할 필요 없음. 그래서 방법 2를 써서 구축할 수 있음.
- 가변 비트리에는 수정을 위해서 일부 공간을 남겨줌. 이걸 공간 오버헤드라고 함. 항상 꽉 차있으면 매번 분할을 해야 하기 때문임. 그래서 미래의 시간 효율성을 위해 현재의 공간 효율성을 희생하는 것.
- 근데 불변 비트리는 오버헤드가 왜 없냐? 당연히 미래의 삽입을 염두에 두고 공간을 미리 남겨둘 필요가 없기 때문임.
- 그럼 노드 점유율이 높아지고, 페이지 당 더 많은 키를 담을 수 있고, 트리의 높이가 낮아지므로 검색 성능이 향상되고, 하나의 페이지를 읽을 때 더 많은 키가 있으므로 디스크 IO가 개선됨 (전부 배웠던 내용)