# 고급 백엔드 스터디 6주차

## Implementing B-Trees

이전 장에서는 바이너리 포맷 구성의 일반적인 원칙에 대해 설명하고, 셀을 생성하고 계층 구조를 구축하며 포인터를 사용해 이를 페이지에 연결하는 방법을 배웠습니다. 이러한 개념은 in-place 업데이트 방식과 append-only 저장 구조 모두에 적용됩니다. 이번 장에서는 B-트리에 특화된 개념들을 다룹니다.

이 장의 내용은 세 가지 논리적 범주로 나뉩니다. 먼저, 키와 포인터 간의 관계를 설정하는 방법, 페이지 간의 헤더와 링크를 구현하는 방법 등 조직 구조에 대해 논의합니다.

그다음으로는 루트에서 리프까지 내려가는 과정에서 발생하는 작업들, 즉 이진 탐색 수행 방법, 추후 분할이나 병합을 위해 부모 노드를 추적하고 브레드크럼(breadcrumbs)를 수집하는 방법에 대해 설명합니다.

마지막으로는 리밸런싱, 우측 전용 추가(right-only appends), 일괄 적재(bulk loading)와 같은 최적화 기법들, 유지 관리 프로세스, 그리고 가비지 컬렉션에 대해 설명합니다.

- 이전 장에서는 1) 바이너리 포맷 구성을 위한 general principles 2) 셀을 만들고 계층 구조를 만들고 포인터를 사용하여 페이지에 연결하는 법을 배웠음. 해당 방식은 in-place와 append-only 모두 해당됨.
- 이번 장에서는 b-tree에 특화된 개념을 다룰 것. 세 가지 범주로 나뉨
    - 구조 관련
        - 키와 포인터 관계
        - 페이지 간 연결, 헤더 구현 방식
        - 비트리 노드 구성 방식
    - 트리 순회 관련
        - 이진 탐색을 통해 키를 찾는 법
        - 구조 변경을 고려하여 부모 노드 추적
        - breadcrumb stack 자료구조 관련
    - 최적화와 유지보수
        - 리밸런싱 → 노드 데이터 재분배하여 split을 늦추는 것
        - right-only append → 키가 순차적일 때 빠르게 추가하게 만들기
        - bulk loading → 정렬된 데이터 한 번에 삽입
        - GC → 미사용 데이터 공간 회수하여 컴팩션 수행

## Page Header

페이지 헤더는 탐색, 유지 관리 및 최적화에 사용될 수 있는 페이지 관련 정보를 저장합니다. 일반적으로 페이지의 내용과 레이아웃을 설명하는 플래그, 페이지에 있는 셀의 수, 빈 공간을 나타내는 하단 및 상단 오프셋(셀 오프셋 및 데이터를 추가하는 데 사용됨), 그리고 기타 유용한 메타데이터를 포함합니다.

예를 들어, PostgreSQL은 페이지 크기와 레이아웃 버전을 헤더에 저장합니다. MySQL InnoDB에서는 힙 레코드 수, 레벨, 그리고 몇 가지 구현 세부 값들을 페이지 헤더에 저장합니다. SQLite에서는 페이지 헤더에 셀의 수와 가장 오른쪽 포인터를 저장합니다.

- 페이지 헤더는 페이지 구조를 요약하는 정보를 저장함
    - 탐색 → 어떤 포인터를 따라갈 것인지
    - 메인터넌스 → 페이지 정리나 병합할 때 판단 기준
    - 최적화 → 접근 시 불필요한 연산, IO 방지
- 저장되는 정보 구성
    - 플래그 → 페이지 개요 (ex: 리프 노드 여부)
    - 셀의 수
    - 빈 공간의 하단 / 상단 오프셋 → 데이터와 셀 포인터를 어디에 추가할 수 있는지 알려줌. 5주차 참고
    - 그 외 메타데이터
- 예시
    - PostgreSQL → 페이지 크기와 레이아웃 버전 (포맷 관련)
    - MySQL InnoDB → 힙 레코드 수, 노드 레벨 (B-Tree 구조 관련)
    - SQLite → 셀 수, 오른쪽 포인터 (삽입 성능 최적화)
- MySQL InnoDB 실제 구조를 확인해보자.
    - [https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/](https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/)

### Magic Numbers

파일 또는 페이지 헤더에 자주 저장되는 값 중 하나는 매직 넘버입니다. 일반적으로 매직 넘버는 고정된 값을 포함하는 멀티바이트 블록으로, 해당 블록이 페이지를 나타내는지, 어떤 종류인지, 또는 어떤 버전인지를 식별하는 데 사용됩니다.

매직 넘버는 종종 유효성 검사와 건전성 확인(sanity check)에 사용됩니다 [GIAMPAOLO98]. 임의의 오프셋에서 해당 바이트 시퀀스가 정확히 매직 넘버와 일치할 가능성은 매우 낮습니다. 따라서 일치한다면 해당 오프셋이 올바를 가능성이 높습니다. 예를 들어, 페이지가 올바르게 로드되고 정렬되었는지를 확인하기 위해, 쓰기 시점에 헤더에 50 41 47 45 (16진수로 PAGE) 값을 매직 넘버로 삽입할 수 있습니다. 읽기 시점에서는 헤더에서 읽은 네 바이트가 예상된 바이트 시퀀스와 일치하는지를 비교하여 페이지를 검증합니다.

- 매직 넘버?
    - 파일 / 페이지 헤더에 있는 고정된 값을 가진 바이트 블록
    - 용도
        - 페이지인지 아닌지 확인
        - 페이지 종류, 버전 식별
    - 목적
        - 유효성 체크
        - 건전성(sanity) 체크 → 모든 조건을 다 따지지 않고 명백하게 잘못된 값이 아닌지 검사
    - 왜 매직 넘버인가?
        - 랜덤하게 만들어진 바이트 시퀀스가 우리가 약속한 값과 위치에 등장할 가능성은 매우 낮음
        - 따라서 그 값이 그 위치에 있다면 매우 높은 확률로 정상적인 위치
    - 예시
        - PAGE에 해당하는 16진수를 매직 넘버로 사용하고, 헤더에 삽입. 읽을 때 동일한 값이 그 위지에 있는지 검증

### Sibling Links

일부 구현에서는 왼쪽과 오른쪽 형제 페이지를 가리키는 전방 및 후방 링크를 저장합니다. 이러한 링크는 부모 노드로 되돌아가지 않고도 인접 노드를 찾는 데 도움이 됩니다. 이 방식은 분할(split) 및 병합(merge) 작업에 복잡성을 추가하는데, 형제 노드의 오프셋도 함께 갱신되어야 하기 때문입니다. 예를 들어, 오른쪽 끝이 아닌 노드가 분할되는 경우, 그 오른쪽 형제 노드의 후방 포인터(이전에는 분할되기 전 노드를 가리켰던)는 새로 생성된 노드를 가리키도록 다시 설정해야 합니다.

그림 4-1에서 확인할 수 있듯이, 형제 노드가 연결되어 있지 않다면 형제 노드를 찾기 위해 부모 노드를 참조해야 합니다. 이 작업은 최상위 루트까지 거슬러 올라갈 수도 있습니다. 왜냐하면 직접적인 부모 노드는 자기 자식들만 식별할 수 있기 때문입니다. 만약 형제 링크를 헤더에 직접 저장한다면, 동일 레벨에서 이전 또는 다음 노드를 단순히 따라가기만 하면 됩니다.

형제 링크를 저장할 때의 단점 중 하나는, 분할이나 병합이 일어날 때 이 링크들을 반드시 갱신해야 한다는 점입니다. 갱신은 분할/병합이 일어나는 노드가 아니라 그 형제 노드에서 수행되어야 하므로 추가적인 락킹(locking)이 필요할 수 있습니다. 이러한 형제 링크가 동시성 B-트리 구현에서 어떻게 유용할 수 있는지는 “Blink-Trees” 절에서 설명합니다.

- 예전에 B+-Tree에서 단말 노드에서 부모 노드로의 포인터 말고도 좌우 형제 노드로도 오갈 수 있는 포인터를 가진다고 이야기했었음. 이러한 포인터가 범위 탐색에 도움이 된다는 점도 언급했었음
- 이걸 형제 링크라고 함
- 단점 → 분할 / 병합 시 형제 노드 포인터까지 같이 수정해야 하기 때문에 복잡해짐.
    - 가령 A B가 연결되어 있고, A가 분할되어 A A’ B가 된다고 하자.
    - A가 A, A’로 분할되는 과정은 기존과 동일하지만, B의 왼쪽 형제 링크가 여전히 A를 가리키고 있기 때문에, A’를 가리키도록 B의 후방 포인터를 갱신해야 함
    - 이 갱신은 분할/병합 발생 노드(A, A’)가 아닌 형제 노드(B)에서 수행되므로 락이 필요
        - 만약 B에 락을 걸지 않고 수정한다면? 다른 스레드에서 B에 접근하고 있을 때 동시성 이슈가 발생 가능

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%206%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20202998e1b709809bbc3fcf6f8a036452/image.png)

### Rightmost Pointers

B-Tree에서 구분 키(separator key)는 엄격한 불변 조건(invariant)을 가집니다. 구분 키는 트리를 여러 서브트리로 분할하고 탐색하는 데 사용되므로, 항상 키의 개수보다 하나 더 많은 자식 페이지 포인터가 존재합니다. 이것이 "Counting Keys"에서 언급된 +1의 의미입니다.

"Separator Keys" 섹션에서 구분 키의 불변 조건에 대해 설명했습니다. 많은 구현에서는 노드가 Figure 4-2에 나타난 것처럼 구성되어 있습니다. 각 구분 키는 하나의 자식 포인터를 가지며, 마지막 포인터는 어떤 키와도 짝을 이루지 않기 때문에 별도로 저장됩니다. 이는 Figure 2-10과 비교해볼 수 있습니다.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%206%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20202998e1b709809bbc3fcf6f8a036452/image%201.png)

- B-Tree에서 구분 키는 엄격한 불변식을 가짐 → 키의 개수보다 하나 더 많은 자식 포인터가 존재
- 한편 (p, k)와 같이 각 키와 포인터는 쌍을 이루므로 맨 오른쪽 포인터는 항상 쌍을 이루지 못하고 남게 됨.
    - 왜 (p, k) 일까? (k, p) 하면 가장 왼쪽 포인터가 남을 텐데…
    - 그건 탐색 방식과 관련이 있음. 만약 키를 비교하다가 K1과 정확하게 일치하는 값을 발견했다고 해보자. 그렇다면
        - 만약 (p, k) 쌍이라면 K_1 ≤ K_s < K_2에 해당하는 범위를 나타내는 포인터가 바로 왼쪽에 있으니 접근하면 됨
        - 근데 (k, p) 쌍이라면? 이 쌍의 포인터는 키보다 더 큰 경우에 대한 케이스이므로, 결국 다음 쌍으로 가서 비교를 해봐야 함. 다음 쌍에서 또 작다는 게 확인되었으면 이전 포인터가 가리키는 곳으로 되돌아가서 접근해야 함. 즉 인덱스 - 1을 해줘야 하기 때문에 단점.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%206%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20202998e1b709809bbc3fcf6f8a036452/image%202.png)

이 추가 포인터는 SQLite에서처럼 헤더에 저장될 수 있습니다.

오른쪽 끝(rightmost)의 자식 노드가 분할되고 새로운 셀이 상위 노드에 추가되는 경우, 오른쪽 자식 포인터는 다시 할당되어야 합니다. Figure 4-3에서 볼 수 있듯이, 분할 이후 상위 노드에 추가된 셀(회색으로 표시됨)은 승격된 키(promoted key)를 가지고 분할된 노드를 가리킵니다. 새로운 노드를 가리키는 포인터가 기존 오른쪽 포인터 대신 할당됩니다. 이와 유사한 접근 방식이 SQLite에서 설명되고 구현되어 있습니다.

- SQLite에서 이 오른쪽 끝 포인터는 헤더에 저장될 수도 있음 → 짝이 없기 때문
    - 셀로 만들면 불필요한 정보들을 채워야 함. 키라던가… → 헤더에 저장하면 간단
    - 분할 케이스에서 상위 노드에 승격된 키를 가진 셀이 추가되는 경우, 해당 상위 노드의 rightmost pointer를 갱신해줘야 함 → 가장 오른쪽에 위치한 자식 노드가 변경되었기 때문.

### Node High Keys

조금 다른 접근 방식으로, 오른쪽 끝 포인터(rightmost pointer)를 셀 안에 노드 상한 키(high key)와 함께 저장할 수 있습니다. 이 high key는 현재 노드 아래의 서브트리에서 존재할 수 있는 가장 큰 키를 나타냅니다. 이 접근 방식은 PostgreSQL에서 사용되며, Blink-Trees라고 불립니다(이 방식의 동시성 관점에 대해서는 “Blink-Trees” 절을 참고하십시오).

Blink-Trees는 각 노드에 KN+1 키를 추가합니다. 이는 PN 포인터가 가리키는 서브트리에 저장될 수 있는 키의 상한을 지정하며, 결과적으로 현재 서브트리에 저장될 수 있는 값들의 상한이 됩니다. 두 방식은 Figure 4-4에 나타나 있습니다: (a)는 high key가 없는 노드를, (b)는 high key가 있는 노드를 보여줍니다.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%206%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20202998e1b709809bbc3fcf6f8a036452/image%203.png)

이 경우, 포인터를 쌍으로 저장할 수 있으며, 각 셀이 해당 포인터를 가질 수 있어서, 오른쪽 끝 포인터를 다루는 작업이 단순해질 수 있습니다. 예외 처리가 많지 않기 때문입니다.

Figure 4-5에서는 두 방식의 페이지 구조를 도식화한 것을 볼 수 있으며, 각 경우에서 탐색 공간이 어떻게 나뉘는지를 보여줍니다: 첫 번째 방식에서는 +∞까지 확장되고, 두 번째 방식에서는 K3의 상한까지로 제한됩니다.

![image.png](%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%206%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20202998e1b709809bbc3fcf6f8a036452/image%204.png)

- 오른쪽 끝 포인터를 셀 안에 두고, 대신 해당 노드에 대하여 키의 최댓값(해당 노드의 서브트리 중에서 존재하는 값 중 최댓값), 즉 high key를 같이 저장할 수도 있음
    - 이러한 방식은 PostgreSQL에서 사용되고 Blink-Tree 구조라고 함.

B-트리는 N개의 키(Ki)와 N+1개의 포인터(Pi)를 가집니다. 각 서브트리의 키는 Ki-1 ≤ Ks < Ki 범위로 제한됩니다. 이때 K0 = -∞는 암묵적으로 존재하며, 노드에는 포함되지 않습니다.

- B 트리 구조의 경우 p0 k1 p1 … 방식이고, k0는 -inf이기 때문에 노드에 포함되지 않는 암묵적인 값임
    - 그렇다면 k0 ≤ ki < k1 범위는 p0이 , k1 ≤ ki < k2는 p1, … 순으로 매핑됨
    - 또한 마지막 포인터 p_N의 경우 짝을 이루지 않게 되므로, 유일하게 p_N에 대응되는 범위만 명시적 상한값이 존재하지 안헥 됨
- Blink-트리는?
    - 각 노드에 K_{N+1} 키를 추가함. 즉 원래는 p_N은 S에 대하여 k_N ≤ k_S 범위를 나타내는 값인데, 이 키의 등장으로 k_N ≤ k_S < k_{N+1}의 범위를 나타내게 됨 → 즉 명시적 상한값을 추가
- 장점은?
    - 포인터와 키가 항상 쌍을 이루게 됨 (p, k)
    - 기존에는 마지막이 쌍을 이루지 않기 때문에 엣지 케이스 처리가 필요했는데, 일관되게 처리할 수 있다는 장점

### Overflow Pages

노드 크기와 트리의 팬아웃(fanout) 값은 고정되어 있으며 동적으로 변경되지 않습니다. 트리에 가변 크기의 값들이 존재하고 이들이 충분히 클 경우, 한 페이지만으로는 몇 개만 저장할 수 있게 됩니다. 반면 값이 매우 작다면 예약된 공간이 낭비되게 됩니다.

- 노드 크기 = 페이지 크기이고 이는 4KB or 8KB로 고정되어 있음. 동적으로 변경되지 않음.
- 트리에 매우 큰 가변 크기 값을 저장한다고 해보자. 그러면 한 페이지에 몇 개만 들어갈 수 있을 거임. / 반대로 가변 크기 값이 매우 작다면 공간이 낭비되게 될 것임
    - 가령 4KB 페이지에 키가 100개 존재한다면, 하나 당 40B를 상정하고 있을 것. 근데 1KB 짜리 값을 가진 게 들어온다면 4개밖에 저장 못함 → 즉 이론적인 fanout과 실제로 저장 가능한 개수가 다름
    - 반대로 하나 당 40B를 상정했는데 4B짜리 값들만 들어온다면 현실적으로는 10000개까지도 가능한데, 100개만 상정해뒀기 때문에 낭비 → 마찬가지로 실제로 저장 가능한 개수는 더 많이도 가능

B-트리 알고리즘은 각 노드가 일정 개수의 항목을 유지하도록 규정하고 있습니다. 그러나 값들의 크기가 서로 다르기 때문에, 알고리즘 상으로는 노드가 아직 가득 차지 않은 상태임에도 불구하고, 해당 노드를 담고 있는 고정 크기 페이지에 여유 공간이 없는 상황이 발생할 수 있습니다. 페이지 크기를 재조정하는 작업은 이미 기록된 데이터를 새로운 위치로 복사해야 하므로 실용적이지 않습니다. 그럼에도 불구하고, 페이지 크기를 확장하거나 늘릴 수 있는 방법은 필요합니다.

- 이렇게 고정 노드 크기 + 고정 fanout은 구현이 간단하지만 데이터 크기가 가변적인 경우 비효율적임
    - 이는 이론적 환경과 현실의 물리적 환경 간 불일치 때문임
- 그럼 페이지 크기를 늘려볼까? → 이러면 기존 페이지 데이터를 새로운 페이지로 옮겨야 함. 즉 마이그레이션 과정이 필요한데, 당연히 매우 비싸고 위험. 마이그레이션 과정에서의 데이터 유실이나 인덱스 구조 변경 등…
- 그럼 어떻게? → 기존 페이지는 그대로 두고, 확장할 수 있는 방법을 강구해보자

연속된 새로운 공간으로 데이터를 복사하지 않고 가변 크기 노드를 구현하려면, 여러 개의 연결된 페이지로 노드를 구성할 수 있습니다. 예를 들어, 기본 페이지 크기가 4K일 때 몇 개의 값을 삽입한 뒤 전체 데이터 크기가 4K를 초과하게 되면, 임의의 크기를 허용하는 대신 4K 단위로 증가할 수 있도록 허용합니다. 그래서 4K 크기의 확장 페이지를 할당하고 이를 원래 페이지에 연결합니다. 이렇게 연결된 페이지 확장은 오버플로 페이지(overflow pages)라고 부릅니다. 이 절에서는 명확히 하기 위해 원래의 페이지를 기본(primary) 페이지라고 부릅니다.

- 우리가 아까 전 논의한 방식은 페이지 크기를 키우고, 기존 페이지 데이터를 새로 커진 페이지로 복사하는 방식이었음. 이 방식은 여러 문제가 있다고 했었음
- 그러면 어떻게? 페이지 크기를 키우는 대신, 크기는 그대로 두고 여러 개의 페이지를 사용하는 방식을 고려해볼 수 있음. 대신 페이지 크기 단위로 늘어나게 해야 함. 가령 6KB라면 4KB 페이지 2개를 쓰는 식으로. 이렇게 해야 하는 이유는 앞에서 다뤘음 → 페이지 단위 IO가 가지는 장점 때문
- 그리고 헤더에 다음 페이지 ID를 저장하여 연속되지 않은 페이지에 대해서도 저장할 수 있게 한다
- 이러한 링크드 리스트 형태의 페이지를 ‘overflow page’ 라고 함. 그리고 리스트의 시작이 되는 페이지를 ‘primary page’ 라고 함.

대부분의 B-트리 구현은 B-트리 노드에 고정된 개수의 페이로드 바이트만 저장할 수 있도록 허용하고, 나머지는 오버플로 페이지로 넘깁니다. 이 값은 노드 크기를 팬아웃으로 나누어 계산됩니다. 이 방식을 사용하면, 페이지에 여유 공간이 전혀 없는 상황은 발생하지 않게 됩니다. 왜냐하면 항상 최소한 max_payload_size 바이트는 존재하기 때문입니다. SQLite에서의 오버플로 페이지에 대한 자세한 내용은 SQLite 소스 코드 저장소를 참고하고, MySQL InnoDB 문서도 참고하세요.

- 하나의 페이지에 저장할 수 있는 페이로드 크기는 정해져있음. 그 이상이라면 오버플로로 넘김
- 이 최댓값은 노드 크기 / 팬아웃으로 계산됨 → 노드 4KB, 팬아웃 40이면 100바이트. 이걸 max_payload_size로 설정
- 이렇게 하면 각 노드 당 들어가는 크기가 제한되므로, 이론적 환경(b-tree)와 물리적 환경(노드 크기) 불일치를 해소할 수 있음. 왜? 너무 큰 엔트리는 오버플로 페이지로 잘라서 넘기기 때문에, 물리적으로 수용할 수 있는 한도 내에서만 데이터를 저장할 수 있게 되기 때문

삽입된 페이로드가 max_payload_size를 초과하는 경우, 해당 노드에 이미 연결된 오버플로 페이지가 있는지를 확인합니다. 만약 오버플로 페이지가 이미 존재하고, 거기에 충분한 여유 공간이 있다면, 페이로드의 나머지 바이트를 그곳에 저장합니다. 그렇지 않다면 새로운 오버플로 페이지를 할당합니다.

- 여기서 중요한 점은 해당 페이지에 연결된 오버플로 페이지를 체크한다는 것. 특정한 엔트리에서 오버플로가 나서 오버플로 페이지를 사용했다면, 거기서 쓴 오버플로 페이지를 전부 쓰지 않을 수도 있을 것. 그러면 그 오버플로 페이지의 빈 공간이 낭비되는데, 이를 막기 위해서 페이지 내 다른 엔트리에서 오버플로가 발생하면 기존에 쓰던 오버플로 페이지 빈 공간을 재활용하겠다 라는 뜻
    - SQLite → BLOB 값 크면 처음 일부는 리프 페이지, 나머지는 오버플로 체인에 저장
    - InnoDB → TEXT, BLOB은 768바이트 초과 시 외부 페이지에 저장하고, FIL 헤더의 FIL_PAGE_NEXT 필드 포인터를 따라 다음 오버플로 페이지를 체인처럼 따라가면서 읽음

Figure 4-6에서는 기본(primary) 페이지와 오버플로 페이지를 확인할 수 있으며, 레코드는 기본 페이지에서 오버플로 페이지로 이어지도록 포인터를 가집니다. 이때 페이로드의 나머지 부분이 오버플로 페이지에 저장됩니다.

오버플로 페이지는 기본 페이지와 마찬가지로 단편화될 수 있으므로, 추가적인 부가 작업이 필요합니다. 즉, 새로운 데이터를 쓰기 위해 이 공간을 회수하거나, 필요 없는 경우 오버플로 페이지를 제거해야 합니다.

- 오버플로 페이지 역시 단편화를 고려해야 함
    - 기존에 하던 대로 빈 공간이 생기면 기록해놨다가 (예전에 fit 부분 참고) 거기에 쓰거나
    - 페이지를 꽉 채워서 쓰던 데이터가 없어진 경우라면 페이지 자체를 제거할 수도 있음

처음 오버플로 페이지가 할당되면, 그 페이지 ID는 기본 페이지의 헤더에 저장됩니다. 하나의 오버플로 페이지로 충분하지 않은 경우, 여러 개의 오버플로 페이지를 서로 연결하여 사용합니다. 이전 오버플로 페이지의 헤더에 다음 페이지의 ID를 저장함으로써 이를 실현합니다. 주어진 페이로드에 대해 오버플로 영역을 찾으려면 여러 페이지를 순차적으로 탐색해야 할 수도 있습니다.

- 페이지 헤더에 오버플로 페이지 ID를 저장하여, 링크드 리스트처럼 따라가면서 읽음

일반적으로 키는 고유도가 높기 때문에, 키의 일부만 저장하는 것도 유용합니다. 대부분의 비교 연산은 기본 페이지에 존재하는 키의 잘린(truncated) 부분으로도 수행할 수 있기 때문입니다.

- 키는 카디널리티가 높음 → 앞부분이 모두 일치해서 뒷부분까지 비교해야 하는 경우 드묾. 따라서 앞부분만 비교하더라도 충분한 경우가 많음. 그러므로 키를 모두 저장하는 게 아니라, 키를 절사해서 일부부만 저장하면 페이지 헤더가 많은 공간을 먹는 걸 막을 수 있음.

데이터 레코드의 경우, 사용자에게 반환하기 위해 오버플로 영역의 값을 찾아야 합니다. 하지만 이 작업은 자주 일어나지 않으므로 큰 문제는 아닙니다. 만약 모든 데이터 레코드가 크기가 크다면, 대용량 값을 위한 특수화된 BLOB 저장소를 고려하는 것이 좋습니다.

- 데이터 레코드의 경우 오버플로 페이지 체인을 따라가면서 값을 읽어야 함 → 디스크 IO 이슈. 하지만 이런 케이스는 많지 않음. 갑자기 길이가 튀는 케이스는 많지 않으니까…
- 만약에 모든 레코드가 전부 긴 경우라면? 전부 오버플로가 발생한다면? 그러면 BLOB 저장소를 쓰는 게 좋다.

## Binary Search

우리는 이미 “B-트리 탐색 알고리즘”에서 B-트리 탐색 알고리즘에 대해 논의하면서, 노드 내에서 검색할 키를 이진 탐색 알고리즘을 이용하여 찾는다고 언급한 바 있습니다. 이진 탐색은 정렬된 데이터에만 동작합니다. 키들이 정렬되어 있지 않다면, 이진 탐색을 사용할 수 없습니다. 그렇기 때문에 키들을 정렬된 상태로 유지하고, 정렬 불변식을 유지하는 것이 필수적입니다.

이진 탐색 알고리즘은 정렬된 항목 배열과 검색할 키를 받아 숫자를 반환합니다. 반환된 숫자가 양수라면, 검색한 키가 존재하며 이 숫자는 입력 배열에서 해당 키의 위치를 나타냅니다. 반환값이 음수라면, 검색한 키가 배열에 존재하지 않으며 이 숫자는 삽입 지점을 나타냅니다.

삽입 지점은 주어진 키보다 큰 첫 번째 요소의 인덱스입니다. 이 숫자의 절댓값은 정렬된 상태를 유지하면서 키를 삽입할 수 있는 인덱스입니다. 삽입은 삽입 지점부터 요소들을 한 칸씩 뒤로 이동시켜 자리를 만드는 방식으로 수행할 수 있습니다 [SEDGEWICK11].

상위 레벨에서의 대부분의 탐색은 정확한 일치를 찾기보다는 방향을 결정하는 것이 목적이며, 이 경우에는 검색한 키보다 큰 첫 번째 값을 찾아 해당하는 자식 링크를 따라 관련된 서브트리로 내려가야 합니다.

- B-트리 탐색 시 여러 개의 구분 키 중 어디 사이로 들어가야 할 지 결정하기 위해서 이진 탐색을 활용한다고 했었음.
- 근데 이진 탐색 전제조건은 키들이 정렬되어 있어야 한다는 것.
- 이진 탐색 알고리즘은 정렬된 키들과 검색 대상 키를 받아서 특정한 숫자를 반환. 즉 retval = f(sorted_items, target_key)
- retval 의미? → 양수 음수 따라 다름. 양수 → 해당 키의 위치. 음수가 중요한데, 일치하는 키가 없는 경우. 우리가 알고리즘 풀 때는 없다면 그냥 -1 던지는 식이었지만, 여기서는 키가 없더라도 삽입을 위해서 써먹어야 하는 경우 있기 때문에 1부터 시작하는 음수 인덱스로 해석함. 가령 -4라면 4번째 위치 (0-base index가 아니다!)
- 삽입 로직 → 키로 노드를 결정하고 결정하고 인덱스로 세부 위치 결정. 삽입 시 그 뒤에 있는 원소들을 한 칸씩 밀기.
- 상위 레벨에서는 검색 대상 키에 대하여 이것보다 ‘첫 번째로 큰’ 걸 찾으면서 그 서브트리로 타고 들어가는 게 목적

### Binary Search with Indirection Pointers

B-트리 페이지의 셀들은 삽입 순서대로 저장되며, 논리적인 요소 순서는 오직 셀 오프셋(offset)에 의해서만 유지됩니다. 페이지 셀에 대해 이진 탐색을 수행하기 위해서는, 중간 셀의 오프셋을 선택하고, 해당 포인터를 따라 셀의 위치를 찾은 다음, 그 셀의 키를 검색 키와 비교하여 탐색을 왼쪽으로 계속할지 오른쪽으로 계속할지를 결정하고, 검색한 항목 또는 삽입 지점을 찾을 때까지 이 과정을 재귀적으로 반복합니다. 이 과정은 Figure 4-7에 나타나 있습니다.

- 실제 셀들은 삽입 순서대로 넣고, 대신 셀 오프셋- 즉 셀 포인터 배열에서 이 논리적인 키 순서들을 관리하여 이진 탐색을 위해 정렬된 상태를 유지하게 함.
- 실제 키 대상 이진 탐색을 위해서는 셀 오프셋 배열을 사용하고, 실 데이터가 필요한 경우에만 포인터를 통해 셀에 접근
- 이진 탐색에서는 중간값이 필요한데, 중간 셀의 ‘오프셋’을 선택하고, 이를 재귀적으로 반복하여 진행함
- 즉 이진 탐색에서는 오프셋이 메인으로 활용되며 실제 셀 데이터의 순서는 의미 없음. 슬롯 페이지 개념에서 언급했으니 스킵

## Propagating Splits and Merges

이전 장에서 살펴본 것처럼, B-트리의 분할(split)과 병합(merge)은 상위 레벨로 전파될 수 있습니다. 이를 위해서는 분할되는 리프 노드나 병합되는 리프 쌍으로부터 루트 노드까지 거슬러 올라갈 수 있는 경로를 따라 이동할 수 있어야 합니다.

B-트리 노드는 상위(parent) 노드에 대한 포인터를 포함할 수 있습니다. 하위 레벨의 페이지는 항상 상위 레벨로부터 참조될 때 페이징되기 때문에, 이러한 정보는 디스크에 영구적으로 저장할 필요는 없습니다.

형제 포인터(sibling pointer)와 마찬가지로(“Sibling Links” 참조), 부모 포인터 역시 부모가 변경될 때마다 갱신되어야 합니다. 이는 구분 키(separator key)와 페이지 식별자(page identifier)가 하나의 노드에서 다른 노드로 이동될 때 발생합니다. 예를 들어, 부모 노드가 분할되거나 병합되거나 리밸런싱될 때 이러한 변화가 발생합니다.

일부 구현체(예: WiredTiger)는 형제 포인터 사용 시 발생할 수 있는 데드락을 방지하기 위해 리프 노드 순회 시 부모 포인터를 사용합니다([MILLER78], [LEHMAN81] 참조). 형제 포인터 대신 부모 포인터를 활용하여 리프 노드를 순회하는 방식은 Figure 4-1에서도 확인할 수 있습니다.

형제 노드를 찾기 위해 부모 노드로부터 포인터를 따라가면서 재귀적으로 하위 레벨로 내려갈 수 있습니다. 부모 노드 내의 모든 형제를 순회한 후에도 형제를 찾지 못했다면, 검색은 다시 상위 노드로 재귀적으로 올라가며, 최종적으로 루트까지 도달한 후 다시 리프 레벨로 내려가면서 계속됩니다.

- 예전에 2장에서 봤듯이 비트리 분할 병합은 상위 레벨로 전파됨 (상위 레벨에서도 키를 수용 못하는 경우)
- 이런 변경이 발생했을 때 현재 노드에서 부모 노드로 거슬러 올라갈 수 있어야 함 → 즉 부모 노드를 알 수 있어야 한다. 자식 노드 입장에서
- 보통 B-Tree는 부모 → 자식 포인터만 있지만, 자식 → 부모 포인터도 가질 수 있음. 다만 그게 자식 → 부모 포인터를 디스크에 영구적으로 저장해야 한다는 말은 아님. 이게 무슨 말이냐면…
    - 어차피 디스크에서 B-Tree가 로드될 때 루트 → 비단말 → 단말 식으로 메모리에 올라옴
    - 이 말은 상위 노드가 메모리에 이미 존재해야지만 하위 노드도 올라올 수 있다는 뜻임
    - 그래서 디스크에 이걸 저장할 필요 없이 메모리 단에서만 유효하게 동작하면 됨. 즉 메모리 레벨 정보면 충분.
- 형제 포인터 때 한 쪽 노드에서 분할되더라도 실제로 분할이 일어나지 않는 다른 한 쪽 역시 형제 포인터를 갱신해줘야 한다고 했었음. 마찬가지로 부모 포인터 역시 노드의 부모가 바뀌는 경우 새 부모 노드를 가리키도록 갱신시켜줘야 함
    - 이런 게 어떤 상황에서 생기냐? 부모 노드가 분할되는 경우임. 기존 부모가 A인데 A와 A’로 분할된다고 해보자. 그러면 기존에 A에 속해있던 일부 자식 노드들은 A’에게 속하게 될 것임. 그러면 얘네들의 부모 포인터는 A에서 A’로 바꿔줘야 한다.
    - 병합되는 경우도 마찬가지. 원래 A와 A’이었는데, 합쳐져서 A가 된다면 부모가 A’인 것들은 A로 갱신해줘야 함
- WiredTiger의 경우 형제 포인터 사용 시 데드락 발생 가능
    - 왜? 형제 포인터는 좌 → 우, 우 → 좌 이동 둘 다 가능. 그러므로 1 → 2와 2 → 1에서 서로 락을 잡고 대기하여 데드락이 발생할 수 있음. 부모를 쓰면 항상 위에서 → 아래로 접근하므로 방향이 충돌하지 않으므로 발생 X
    - 부모 노드를 써서 형제 노드를 찾는다? → 형제 포인터를 안 쓴다면, 일단 부모로 올라가서 그 다음 위치 포인터를 타고 다시 내려가는 방식이 유효할 것임. 그 부모에서 전부 못 찾았다면? 부모의 부모 (조부모) 노드로 올라가서 또 반복. 계속해서 반복하다가 루트까지 간다면? 이제 루트의 오른쪽 서브트리에 대해서 타고 내려갈 것임

### Breadcrumbs

부모 노드 포인터를 저장하고 유지하는 대신, 목표 리프 노드까지의 경로에 따라 탐색한 노드들을 추적하고, 삽입 시 연쇄 분할이나 삭제 시 병합이 발생할 경우 부모 노드들의 체인을 역순으로 따라갈 수 있습니다.

B-트리의 구조적 변화(삽입 또는 삭제)가 발생할 수 있는 연산 동안에는, 먼저 루트에서 리프로 트리를 순회하여 대상 노드와 삽입 지점을 찾습니다. 이러한 연산이 분할이나 병합을 유발할지 여부는(적어도 목표 리프 노드에 도달하기 전까지는) 알 수 없기 때문에, 우리는 브레드크럼을 수집해야 합니다.

브레드크럼은 루트부터 따라간 노드들에 대한 참조를 포함하며, 분할이나 병합을 전파할 때 역순으로 되짚는 데 사용됩니다. 이를 위한 가장 자연스러운 자료 구조는 스택입니다. 예를 들어, PostgreSQL은 내부적으로 BTStack이라고 불리는 스택에 브레드크럼을 저장합니다.

노드가 분할되거나 병합되는 경우, 브레드크럼을 사용하여 상위 노드로 전달할 키의 삽입 지점을 찾고, 필요하다면 상위 노드로 거슬러 올라가 구조적 변화를 전파할 수 있습니다. 이 스택은 메모리에서 유지됩니다.

Figure 4-8은 루트에서 리프까지의 순회를 예시로 보여주며, 방문한 노드들과 셀 인덱스가 포함된 브레드크럼을 수집하는 과정을 나타냅니다. 목표 리프 노드가 분할되면, 스택의 최상단 항목을 꺼내어 해당 노드의 직계 부모를 찾습니다. 부모 노드에 충분한 공간이 있다면, 브레드크럼에 있는 셀 인덱스를 사용하여 새 셀이 추가됩니다(인덱스가 여전히 유효하다는 가정 하에). 그렇지 않은 경우, 부모 노드도 분할됩니다. 이 과정은 스택이 비거나 루트에 도달할 때까지, 혹은 해당 레벨에서 분할이 일어나지 않을 때까지 재귀적으로 계속됩니다.

- 부모 노드 포인터를 두는 대신에 탐색 과정에서 방문한 노드 정보를 기억하는 것도 가능 → 이걸 브레드크럼이라고 함. 스택 같은 데에 저장
- 리프 노드에서 삽입 / 삭제 하다 보면 분할 혹은 병합이 발생할 수 있는데, 이로 인해 부모로 변경이 연쇄적으로 전파될 수 있다고 했었음. 이런 구조 변경 케이스에서, 이 브레드크럼 스택에 저장한 경로를 역순으로 쭉 따라가면서 부모 노드를 찾아가면 됨. 이렇게 하면 부모 노드로의 포인터가 없어도 됨
- 좀 더 구체적으로 알아보자. 먼저 브레드크럼의 인덱스는 트리의 레벨이라고 보면 됨. 그리고 브레드크럼 배열의 인덱스로 접근하여 얻을 수 있는 값은 그 노드의 세부 위치, 즉 셀 인덱스임.
    - 이제 삽입 케이스를 가정해보자. 삽입 위치를 식별하기 위해 루트에서 리프로 순회하며 대상 노드 그리고 셀 인덱스를 찾는다 (위에서 말했던 retval).
    - 그런데 삽입으로 인해서 병합이 발생할 수도 있다. 근데 이건 리프에 가기 전까지 모른다. 리프에서 병합이 발생했는데, 이게 위로 얼마나 전파될 지도 모른다. 전파가 된다면 위로 계속 올라가야 할 텐데… 어디까지 역류할 지 모르기 때문에, 일단 처음부터 갔던 곳을 다 저장해둔다. 스택 같은 곳에 브레드크럼을 쌓는다. PostgreSQL은 BTStack이라는 걸 쓴다고 한다.
    - 이제 리프에서 병합이 확정되면 부모 노드로 거슬러 올라가기 위해 브레드크럼을 역순으로 타고 올라간다.